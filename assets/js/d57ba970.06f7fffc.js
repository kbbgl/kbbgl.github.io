"use strict";(self.webpackChunkkgkb=self.webpackChunkkgkb||[]).push([[5090],{86574:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>c,metadata:()=>o,toc:()=>d});var i=s(74848),r=s(28453);const c={},t=void 0,o={id:"software/containerization/k8s/Services/Services_Diagram",title:"Services_Diagram",description:"Services Diagram",source:"@site/docs/software/containerization/k8s/Services/4._Services_Diagram.md",sourceDirName:"software/containerization/k8s/Services",slug:"/software/containerization/k8s/Services/Services_Diagram",permalink:"/docs/software/containerization/k8s/Services/Services_Diagram",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Service_Types",permalink:"/docs/software/containerization/k8s/Services/Service_Types"},next:{title:"Local_Proxy_for_Development_",permalink:"/docs/software/containerization/k8s/Services/Local_Proxy_for_Development_"}},a={},d=[{value:"<code>Service</code>s Diagram",id:"services-diagram",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",img:"img",p:"p",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h2,{id:"services-diagram",children:[(0,i.jsx)(n.code,{children:"Service"}),"s Diagram"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://d33wubrfki0l68.cloudfront.net/2d3d2b521cf7f9ff83238218dac1c019c270b1ed/9ac5c/images/docs/services-ipvs-overview.svg",alt:""})}),"\n",(0,i.jsxs)(n.p,{children:["Kubernetes latest versions starting in 1.11 uses the ",(0,i.jsx)(n.code,{children:"ipvs"})," proxy mode."]}),"\n",(0,i.jsxs)(n.p,{children:["IPVS (IP Virtual Server) is built on top of the Netfilter and implements transport-layer load balancing as part of the Linux kernel. In ",(0,i.jsx)(n.code,{children:"ipvs"})," mode, ",(0,i.jsx)(n.code,{children:"kube-proxy"})," watches Kubernetes ",(0,i.jsx)(n.code,{children:"Services"})," and ",(0,i.jsx)(n.code,{children:"Endpoints"}),", calls ",(0,i.jsx)(n.code,{children:"netlink"})," interface to create IPVS rules accordingly and synchronizes IPVS rules with Kubernetes ",(0,i.jsx)(n.code,{children:"Services"})," and ",(0,i.jsx)(n.code,{children:"Endpoints"})," periodically. This control loop ensures that IPVS status matches the desired state. When accessing a ",(0,i.jsx)(n.code,{children:"Service"}),", IPVS directs traffic to one of the backend Pods."]}),"\n",(0,i.jsx)(n.p,{children:"IPVS provides more options for balancing traffic to backend Pods; these are:"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"rr"}),": round-robin\n",(0,i.jsx)(n.code,{children:"lc"}),": least connection (smallest number of open connections)\n",(0,i.jsx)(n.code,{children:"dh"}),": destination hashing\n",(0,i.jsx)(n.code,{children:"sh"}),": source hashing\n",(0,i.jsx)(n.code,{children:"sed"}),": shortest expected delay\n",(0,i.jsx)(n.code,{children:"nq"}),": never queue"]}),"\n",(0,i.jsxs)(n.p,{children:["IPVS mode is configured via ",(0,i.jsx)(n.code,{children:"--proxy-mode=ipvs"}),". It implicitly uses IPVS NAT mode for service port mapping."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://kubernetes.io/blog/2018/07/09/ipvs-based-in-cluster-load-balancing-deep-dive/",children:"IPVS-Based In-Cluster Load Balancing Deep Div"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Service"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>o});var i=s(96540);const r={},c=i.createContext(r);function t(e){const n=i.useContext(c);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(c.Provider,{value:n},e.children)}}}]);