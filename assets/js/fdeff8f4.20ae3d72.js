"use strict";(self.webpackChunkkgkb=self.webpackChunkkgkb||[]).push([[24492],{96997:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>d,toc:()=>t});var i=s(74848),r=s(28453);const c={title:"Branching/Control Flow"},o="Branching and Control Flow",d={id:"software/languages/assembly/branching-control-flow",title:"Branching/Control Flow",description:"If we want to control the flow of the program (such as adding conditional statements), we would need to use the eip register.",source:"@site/docs/software/languages/assembly/branching-control-flow.md",sourceDirName:"software/languages/assembly",slug:"/software/languages/assembly/branching-control-flow",permalink:"/docs/software/languages/assembly/branching-control-flow",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Branching/Control Flow"},sidebar:"docsSidebar",previous:{title:"Bitwise Operations",permalink:"/docs/software/languages/assembly/bitwise-operations"},next:{title:"Computer Memory",permalink:"/docs/software/languages/assembly/memory/computer-memory"}},l={},t=[{value:"<code>eip</code> Register",id:"eip-register",level:2},{value:"<code>JMP</code> Instruction",id:"jmp-instruction",level:2},{value:"Labels",id:"labels",level:2},{value:"Flags Register",id:"flags-register",level:2},{value:"The Zero Flag (<code>ZF</code>)",id:"the-zero-flag-zf",level:3},{value:"The Sign Flag (<code>SF</code>)",id:"the-sign-flag-sf",level:3},{value:"The Carry Flag (<code>CF</code>)",id:"the-carry-flag-cf",level:3},{value:"The Overflow Flag (<code>OF</code>)",id:"the-overflow-flag-of",level:3},{value:"Overflow and Carry Comparison",id:"overflow-and-carry-comparison",level:3},{value:"Basic Conditional Branching",id:"basic-conditional-branching",level:2},{value:"<code>JZ</code> and <code>JNZ</code>",id:"jz-and-jnz",level:3},{value:"<code>CMP</code>",id:"cmp",level:3},{value:"Unsigned Comparison Instructions",id:"unsigned-comparison-instructions",level:3},{value:"Signed Comparison Instructions",id:"signed-comparison-instructions",level:3},{value:"Structured Branching",id:"structured-branching",level:2},{value:"Conditionals",id:"conditionals",level:3},{value:"Loops",id:"loops",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"branching-and-control-flow",children:"Branching and Control Flow"})}),"\n",(0,i.jsxs)(n.p,{children:["If we want to control the flow of the program (such as adding conditional statements), we would need to use the ",(0,i.jsx)(n.code,{children:"eip"})," register."]}),"\n",(0,i.jsxs)(n.h2,{id:"eip-register",children:[(0,i.jsx)(n.code,{children:"eip"})," Register"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"eip"})," register is the Extended Instruction Pointer."]}),"\n",(0,i.jsxs)(n.p,{children:["It is ",(0,i.jsx)(n.strong,{children:"32 bits"})," in size (64 bits in size in long-mode). In 32 bit protected mode, ",(0,i.jsx)(n.code,{children:"eip"})," cannot be changed."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"It contains/points to the address to the current instruction"}),". If we want to jump to a different instruction, we need to change ",(0,i.jsx)(n.code,{children:"eip"}),"."]}),"\n",(0,i.jsxs)(n.h2,{id:"jmp-instruction",children:[(0,i.jsx)(n.code,{children:"JMP"})," Instruction"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"JMP"})," instruction sets the value of ",(0,i.jsx)(n.code,{children:"eip"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-armasm",children:"JMP ecx ; changes eip to contents of ecx. it will continue from the address ecx\nJMP 777d1044h ; changes eip to 0x777d1044. The program will continue execution on that address\n"})}),"\n",(0,i.jsx)(n.p,{children:"There are two types of jumps:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Absolute jump"}),": Jump to a specified location in memory."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Relative jump"}),": Jump to a location which is X bytes from this location."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The assembler picks the suitable jump type.w"}),"\n",(0,i.jsx)(n.h2,{id:"labels",children:"Labels"}),"\n",(0,i.jsx)(n.p,{children:"When a program is launched, we usually can't predict their loading location."}),"\n",(0,i.jsx)(n.p,{children:"Labels allow us to refer to a location in our program without knowing the exact address of that location at runtime. It is the job of the assembler to translate labels into actual addresses."}),"\n",(0,i.jsx)(n.p,{children:"Example of an infinite loop:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-armasm",children:"    mov ecx, 0\nmy_label:        ; label\n    inc ecx\n    jmp my_label ; eip will jump back to address of instruction 'inc ecx'\n"})}),"\n",(0,i.jsx)(n.h2,{id:"flags-register",children:"Flags Register"}),"\n",(0,i.jsx)(n.p,{children:"Flags values are used to make branches and control the flow in code."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"It's a 32-bit register inside the x86 processor."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"There is no direct access to this register."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Every bit in this register is a flag which represents ",(0,i.jsx)(n.code,{children:"True"})," or ",(0,i.jsx)(n.code,{children:"False"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"It contains bits with a value of the result of the latest calculation and other system-related bits."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:"https://boostnote.io/api/teams/OdksQwLn2/files/2d05e0b92856731702c2f3b2fc293a42b94135cf8f1a8a5d957c4efe5a1d2b68-image.png",alt:"image.png"})}),"\n",(0,i.jsx)(n.p,{children:"Every instruction can have certain effects on some bits of the flags register. It is the 'mood' of the process."}),"\n",(0,i.jsxs)(n.p,{children:["The most important are ",(0,i.jsx)(n.code,{children:"CF"}),", ",(0,i.jsx)(n.code,{children:"ZF"}),", ",(0,i.jsx)(n.code,{children:"SF"})," and ",(0,i.jsx)(n.code,{children:"OF"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"the-zero-flag-zf",children:["The Zero Flag (",(0,i.jsx)(n.code,{children:"ZF"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"The most basic and fundamental flag."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Is set (to 1) whenever the last calculation had a result of 0."}),"\n",(0,i.jsx)(n.li,{children:"Is cleared (set to 0) when the last calculation had a non-zero result."}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-armasm",children:"mov   eax,3h ;no effect on zero flag\nmov   ecx,3h\nsub   eax,ecx ; 3-3 = 0, zf is set (1)\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"the-sign-flag-sf",children:["The Sign Flag (",(0,i.jsx)(n.code,{children:"SF"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"The flag equals the most significant bit of the last result."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-armasm",children:"mov edx,0\ndec edx ; edx == 0xffffffff therefore sf == 1\n\nmov eax,0\ndec eax ; edx == 1 therefore sf == 0\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"the-carry-flag-cf",children:["The Carry Flag (",(0,i.jsx)(n.code,{children:"CF"}),")"]}),"\n",(0,i.jsx)(n.p,{children:"The carry flag understands unsigned addition and subtraction."}),"\n",(0,i.jsx)(n.p,{children:"cf is set to 1 when the addition of two numbers causes a carry out of the most significant bits. For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-armasm",children:"mov eax,ffffffffh\nadd eax,1 ; eax == 0, cf == 1\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-armasm",children:"mov eax,f0h\nmov ecx,35h\nsub cl,al\n\n; cl == 0x45\n; carry flag == 1\n"})}),"\n",(0,i.jsx)(n.p,{children:"It's also set when the subtraction of two numbers requires a borrow into the most significant bits."}),"\n",(0,i.jsx)(n.p,{children:"The carry flag is a good indicator when calculations are not correct."}),"\n",(0,i.jsxs)(n.h3,{id:"the-overflow-flag-of",children:["The Overflow Flag (",(0,i.jsx)(n.code,{children:"OF"}),")"]}),"\n",(0,i.jsx)(n.p,{children:'The overflow flag "understands" signed addition and subtraction according to the two\'s complement representation.'}),"\n",(0,i.jsxs)(n.p,{children:["In addition, ",(0,i.jsx)(n.code,{children:"of"})," is set if the addition of two positive numbers has a negative result or when two negative numbers have a positive result."]}),"\n",(0,i.jsxs)(n.p,{children:["In subtraction, ",(0,i.jsx)(n.code,{children:"of = 1"})," if ",(0,i.jsx)(n.code,{children:"x - y > 0"})," where ",(0,i.jsx)(n.code,{children:"x > 0"})," and ",(0,i.jsx)(n.code,{children:"y < 0"})," or ",(0,i.jsx)(n.code,{children:"of = 1"})," if ",(0,i.jsx)(n.code,{children:"x - y > 0"})," where ",(0,i.jsx)(n.code,{children:"x < 0"})," and ",(0,i.jsx)(n.code,{children:"y > 0"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"It's an indicator that a signed arithmetic has a wrong result."}),"\n",(0,i.jsxs)(n.p,{children:["The processor looks on the most significant bit of the two operands and the msb of the result. The msb of the result represents the sign of the number. If the result of the operation has a 'reasonable' sign, the flag is cleared. If not, it's set.\nIf ",(0,i.jsx)(n.code,{children:"x > 0"})," and ",(0,i.jsx)(n.code,{children:"y < 0"}),", ",(0,i.jsx)(n.code,{children:"of"})," is never set because the result of the operation can be of any sign."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-armasm",children:"mov al,7fh\nmov cl,1h\nadd al,cl\n\n; al == 0x80 (1 0 0 0 | 0 0 0 0) so msb is set, therefore of = 1 \n"})}),"\n",(0,i.jsx)(n.h3,{id:"overflow-and-carry-comparison",children:"Overflow and Carry Comparison"}),"\n",(0,i.jsx)(n.p,{children:"Every subtraction or addition operation will set either flag, no matter if it's signed/unsigned or there's a carry or not."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Code"}),(0,i.jsx)(n.th,{children:"CF"}),(0,i.jsx)(n.th,{children:"OF"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"mov eax,0x0"})," ",(0,i.jsx)("br",{})," ",(0,i.jsx)(n.code,{children:"sub eax,1"})," ",(0,i.jsx)("br",{})," ",(0,i.jsx)(n.code,{children:";eax == 0xffffffff"})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"1"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"0"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"mov dl,0x7f"})," ",(0,i.jsx)("br",{})," ",(0,i.jsx)(n.code,{children:"add dl,0x1"})," ",(0,i.jsx)("br",{})," ",(0,i.jsx)(n.code,{children:";dl == 0x80"})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"0"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"1"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"mov ax,0x5"})," ",(0,i.jsx)("br",{})," ",(0,i.jsx)(n.code,{children:"mov si,0x4"})," ",(0,i.jsx)("br",{})," ",(0,i.jsx)(n.code,{children:"add si,ax"})," ",(0,i.jsx)("br",{})," ",(0,i.jsx)(n.code,{children:";si == 0x9"})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"0"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"0"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"mov cl,0x80"})," ",(0,i.jsx)("br",{})," ",(0,i.jsx)(n.code,{children:"mov dl,0x80"})," ",(0,i.jsx)("br",{})," ",(0,i.jsx)(n.code,{children:"add cl,dl"})," ",(0,i.jsx)("br",{})," ",(0,i.jsx)(n.code,{children:";cl == 0x0"})]}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"1"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"1"})})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"basic-conditional-branching",children:"Basic Conditional Branching"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"JMP"})," instruction unconditionally changes the value of ",(0,i.jsx)(n.code,{children:"eip"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["To be able to jump when a different condition is met, we can use the ",(0,i.jsx)(n.code,{children:"Jcc"})," instruction where ",(0,i.jsx)(n.code,{children:"cc"})," represents some condition. The condition is usually dependent upon the value of one of the flags register."]}),"\n",(0,i.jsx)(n.p,{children:"These are the possible conditional jumps available:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["jump depending on carry flag is set or not, ",(0,i.jsx)(n.code,{children:"JC"})," and ",(0,i.jsx)(n.code,{children:"JNC"})]}),"\n",(0,i.jsxs)(n.li,{children:["jump depending on overflow flag is set or not, ",(0,i.jsx)(n.code,{children:"JO"})," and ",(0,i.jsx)(n.code,{children:"JNO"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"JS"})," and ",(0,i.jsx)(n.code,{children:"JNS"})]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"jz-and-jnz",children:[(0,i.jsx)(n.code,{children:"JZ"})," and ",(0,i.jsx)(n.code,{children:"JNZ"})]}),"\n",(0,i.jsxs)(n.p,{children:["Jump Zero and Jump Not Zero will occur only when the ",(0,i.jsx)(n.code,{children:"ZF"})," is set or not set, respectively."]}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"  mov ax,1\n  dec ax\n  jz my_label \n  add ax,5\nmy_label:\n  add ax,2\n  \n; ax == 2\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"  mov ax,1\n  inc ax\n  jnz my_label \n  add ax,5\nmy_label:\n  add ax,2\n  \n; ax == 9\n"})}),"\n",(0,i.jsx)(n.p,{children:"So we can construct a simple loop:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"mov eax,0\nmov ecx,3\n\nagain:\n  add eax,ecx\n  dec ecx\n  jz outside\n  jmp again\noutside:\n  ...\n  \n"})}),"\n",(0,i.jsxs)(n.p,{children:["Or simpler using ",(0,i.jsx)(n.code,{children:"JNZ"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"mov eax,0\nmov ecx,3\n\nagain:\n  add eax,ecx\n  dec ecx\n  jnz again\n  ...\n  \n"})}),"\n",(0,i.jsx)(n.h3,{id:"cmp",children:(0,i.jsx)(n.code,{children:"CMP"})}),"\n",(0,i.jsxs)(n.p,{children:["This instruction is a simulation of the ",(0,i.jsx)(n.code,{children:"SUB"})," instruction and used for comparison of numbers."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"cmp eax,edx\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Using the instruction doesn't modify the ",(0,i.jsx)(n.code,{children:"eax"})," register (unlike ",(0,i.jsx)(n.code,{children:"sub"}),") but it does modify the values of the flags register."]}),"\n",(0,i.jsx)(n.h3,{id:"unsigned-comparison-instructions",children:"Unsigned Comparison Instructions"}),"\n",(0,i.jsx)(n.p,{children:"We can use the following instructions to perform unsigned number comparison:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"JB"}),": Jump if below, checks if ",(0,i.jsx)(n.code,{children:"CF"})," is set. This instruction is just another name for the ",(0,i.jsx)(n.code,{children:"JC"})," instruction."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"JBE"}),": Jump if below or equal, checks if ",(0,i.jsx)(n.code,{children:"CF"})," or ",(0,i.jsx)(n.code,{children:"ZF"})," is set."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"JA"}),": Jump if above, checks if ",(0,i.jsx)(n.code,{children:"CF"})," and ",(0,i.jsx)(n.code,{children:"ZF"})," is not set."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"JBA"}),": Jump if above or equal, checks if ",(0,i.jsx)(n.code,{children:"CF"})," is not set. This instruction is just another name for the ",(0,i.jsx)(n.code,{children:"JNC"})," instruction."]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"  cmp   eax,ecx\n  jb    my_label ; can use JB or JC since they are synonymous.\n  ; we are here if eax >= ecx\n  jmp   outside\nmy_label:\n  ; we are here if eax < ecx\noutside:\n  ; ...\n"})}),"\n",(0,i.jsx)(n.h3,{id:"signed-comparison-instructions",children:"Signed Comparison Instructions"}),"\n",(0,i.jsx)(n.p,{children:"We can use the following instructions to perform signed number comparison:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"JL"}),": Jump if less, checks if ",(0,i.jsx)(n.code,{children:"SF != OF"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"JLE"}),": Jump if less or equal, checks if ",(0,i.jsx)(n.code,{children:"SF != OF && ZF == 1"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"JG"}),": Jump if greater, checks if ",(0,i.jsx)(n.code,{children:"SF == OF && ZF == 0"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"JGE"}),": Jump if greater or equal, checks if ",(0,i.jsx)(n.code,{children:"SF != OF"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"structured-branching",children:"Structured Branching"}),"\n",(0,i.jsxs)(n.p,{children:["High-level languages use conditionals (",(0,i.jsx)(n.code,{children:"if"}),", ",(0,i.jsx)(n.code,{children:"switch"}),") and loops (",(0,i.jsx)(n.code,{children:"for"}),", ",(0,i.jsx)(n.code,{children:"while"}),"). We can perform the same using Assembly code."]}),"\n",(0,i.jsx)(n.p,{children:"Branching/jumping should be used only for the following operations:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Part of ",(0,i.jsx)(n.code,{children:"break"})," statement."]}),"\n",(0,i.jsxs)(n.li,{children:["Part of ",(0,i.jsx)(n.code,{children:"if"})," statement."]}),"\n",(0,i.jsxs)(n.li,{children:["Part of ",(0,i.jsx)(n.code,{children:"while"})," statement."]}),"\n",(0,i.jsxs)(n.li,{children:["Part of ",(0,i.jsx)(n.code,{children:"for"})," statement."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For ",(0,i.jsx)(n.code,{children:"break"})," and ",(0,i.jsx)(n.code,{children:"if"})," we jump forward."]}),"\n",(0,i.jsxs)(n.p,{children:["For ",(0,i.jsx)(n.code,{children:"while"})," and ",(0,i.jsx)(n.code,{children:"for"})," we jump backwards."]}),"\n",(0,i.jsx)(n.h3,{id:"conditionals",children:"Conditionals"}),"\n",(0,i.jsx)(n.p,{children:"For example, if we have pseudo-code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"if eax < edx:\n eax++\nelse:\n eax--\n\nend if\n"})}),"\n",(0,i.jsx)(n.p,{children:"Can be translated to assembly:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:" cmp eax,edx\n jae else\n inc eax\n jmp end_if\nelse:\n dec eax\nend_if:\n ...\n"})}),"\n",(0,i.jsx)(n.h3,{id:"loops",children:"Loops"}),"\n",(0,i.jsxs)(n.p,{children:["If we have the following pseudo-code for a ",(0,i.jsx)(n.code,{children:"for"})," loop:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"for ecx from 0 to 99 do:\n eax = eax + ecx\n\nend for\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can translate it into Assembly code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:" mov ecx,0\nfor_loop:\n add eax,ecx\n inc ecx\n cmp ecx,100d\n jnz for_loop\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If we have the following pseudo-code for a ",(0,i.jsx)(n.code,{children:"while"})," loop to sum 1+2+3... until we reach 1000:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"eax = 0\necx = 0\nwhile ecx > 1000:\n eax = eax + ecx\n ecx++\nend while\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can translate it into Assembly code:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:" mov eax,0\n mov ecx,0\nwhile_loop:\n cmp eax,1000d\n jae end_while\n \n add eax,ecx\n inc ecx\n jmp while_loop\nend_while:\n ...\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Sometimes we need to break a loop. In high-level languages we use the ",(0,i.jsx)(n.code,{children:"break"})," statement."]}),"\n",(0,i.jsx)(n.p,{children:"Let's say we have a program that would sum numbers until it reaches 1000 but it can't sum more than 300 numbers."}),"\n",(0,i.jsx)(n.p,{children:"In pseudo-code, it would look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"eax = 0\n\nfor ecx from 0 to 299 do:\n eax = eax + ecx\n \n if eax >= 1000:\n  break\n"})}),"\n",(0,i.jsx)(n.p,{children:"In assembly:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:" mov eax,0\n mov ecx,0\nfor_loop:\n add eax,ecx\n cmp eax,1000d\n jae end_for\n inc ecx\n cmp ecx,300d\n jb  for_loop\nend_for:\n ...\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>d});var i=s(96540);const r={},c=i.createContext(r);function o(e){const n=i.useContext(c);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(c.Provider,{value:n},e.children)}}}]);