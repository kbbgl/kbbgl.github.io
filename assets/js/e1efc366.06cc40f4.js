"use strict";(globalThis.webpackChunkkgkb=globalThis.webpackChunkkgkb||[]).push([[35090],{19161:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});var r=s(74848),i=s(28453);const o={title:"Go runtime bootstrap and memory allocator",slug:"go-runtime-bootstrap-memory-allocator",authors:["kbbgl"],tags:["go","runtime","memory","allocator","gc","scheduler","performance","profiling"]},a=void 0,t={id:"software/languages/go/runtime-bootstrap-and-memory-allocator",title:"Go runtime bootstrap and memory allocator",description:"This note condenses two excellent Internals for Interns articles into a mental model you can use while debugging performance, memory, and concurrency issues in Go.",source:"@site/docs/software/languages/go/runtime-bootstrap-and-memory-allocator.md",sourceDirName:"software/languages/go",slug:"/software/languages/go/go-runtime-bootstrap-memory-allocator",permalink:"/docs/software/languages/go/go-runtime-bootstrap-memory-allocator",draft:!1,unlisted:!1,tags:[{inline:!0,label:"go",permalink:"/docs/tags/go"},{inline:!0,label:"runtime",permalink:"/docs/tags/runtime"},{inline:!0,label:"memory",permalink:"/docs/tags/memory"},{inline:!0,label:"allocator",permalink:"/docs/tags/allocator"},{inline:!0,label:"gc",permalink:"/docs/tags/gc"},{inline:!0,label:"scheduler",permalink:"/docs/tags/scheduler"},{inline:!0,label:"performance",permalink:"/docs/tags/performance"},{inline:!0,label:"profiling",permalink:"/docs/tags/profiling"}],version:"current",frontMatter:{title:"Go runtime bootstrap and memory allocator",slug:"go-runtime-bootstrap-memory-allocator",authors:["kbbgl"],tags:["go","runtime","memory","allocator","gc","scheduler","performance","profiling"]},sidebar:"docsSidebar",previous:{title:"Run Tests in go",permalink:"/docs/software/languages/go/run-tests"},next:{title:"Slices and Loops",permalink:"/docs/software/languages/go/slices-and-loops"}},l={},c=[{value:"Related docs in this repo",id:"related-docs-in-this-repo",level:2},{value:"Runtime bootstrap: what runs before <code>main.main</code>",id:"runtime-bootstrap-what-runs-before-mainmain",level:2},{value:"Runtime debug knobs worth remembering",id:"runtime-debug-knobs-worth-remembering",level:3},{value:"Memory allocator: how heap memory is organized and why it\u2019s fast",id:"memory-allocator-how-heap-memory-is-organized-and-why-its-fast",level:2},{value:"Stack vs heap (and why the allocator matters)",id:"stack-vs-heap-and-why-the-allocator-matters",level:3},{value:"Arenas \u2192 pages \u2192 spans \u2192 slots",id:"arenas--pages--spans--slots",level:3},{value:"Size classes (8B \u2192 32KB) and the edges",id:"size-classes-8b--32kb-and-the-edges",level:3},{value:"Span classes (scan vs noscan)",id:"span-classes-scan-vs-noscan",level:3},{value:"Concurrency: <code>mcache</code> \u2192 <code>mcentral</code> \u2192 <code>mheap</code>",id:"concurrency-mcache--mcentral--mheap",level:3},{value:"Sweeping and scavenging: reclaiming memory",id:"sweeping-and-scavenging-reclaiming-memory",level:3},{value:"How to apply this when profiling/debugging",id:"how-to-apply-this-when-profilingdebugging",level:2},{value:"Sources",id:"sources",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"This note condenses two excellent Internals for Interns articles into a mental model you can use while debugging performance, memory, and concurrency issues in Go."}),"\n",(0,r.jsx)(n.h2,{id:"related-docs-in-this-repo",children:"Related docs in this repo"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Profiling (heap/allocs/goroutines)"}),": ",(0,r.jsx)(n.a,{href:"/docs/software/languages/go/profiling-golang-using-pprof",children:(0,r.jsx)(n.code,{children:"pprof.md"})})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Concurrency basics (goroutines/channels)"}),": ",(0,r.jsx)(n.a,{href:"/docs/software/languages/go/channels-and-routines",children:(0,r.jsx)(n.code,{children:"channels-and-routines.md"})})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debugging with Delve"}),": ",(0,r.jsx)(n.a,{href:"/docs/software/languages/go/how-to-debug-go-code-delve",children:(0,r.jsx)(n.code,{children:"debugger.md"})})]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"runtime-bootstrap-what-runs-before-mainmain",children:["Runtime bootstrap: what runs before ",(0,r.jsx)(n.code,{children:"main.main"})]}),"\n",(0,r.jsxs)(n.p,{children:["The entry point of a Go binary is ",(0,r.jsx)(n.em,{children:"not"})," ",(0,r.jsx)(n.code,{children:"main.main"}),". It starts in an architecture-specific runtime entry stub like ",(0,r.jsx)(n.code,{children:"_rt0_amd64_linux"}),", which jumps into ",(0,r.jsx)(n.code,{children:"rt0_go"})," to bootstrap the runtime. During this phase the runtime (roughly):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Creates ",(0,r.jsx)(n.code,{children:"g0"})," and ",(0,r.jsx)(n.code,{children:"m0"})]}),": the initial goroutine (",(0,r.jsx)(n.code,{children:"g0"}),", used for runtime work) and initial OS thread (",(0,r.jsx)(n.code,{children:"m0"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sets up TLS"}),": thread-local storage is used so the runtime can quickly find \u201cthe current goroutine\u201d for a given OS thread."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Detects CPU capabilities"}),": checks CPU/vendor features (and may refuse to run if required instructions aren\u2019t available)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transitions into Go runtime init"}),": saves args, initializes OS/CPU info (including a default ",(0,r.jsx)(n.code,{children:"GOMAXPROCS"}),"), then calls ",(0,r.jsx)(n.code,{children:"schedinit()"})," which wires up the major subsystems."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Inside ",(0,r.jsx)(n.code,{children:"schedinit()"})," the runtime initializes key pieces such as:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stack pools"}),": goroutines start small (e.g. 2KB) and grow; stacks are pooled to make goroutine creation cheap."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Allocator"})," (",(0,r.jsx)(n.code,{children:"mallocinit()"}),"): sets up heap management; later, per-",(0,r.jsx)(n.code,{children:"P"})," caches make the common allocation path lock-free."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Map hashing selection"})," (",(0,r.jsx)(n.code,{children:"alginit()"}),"): chooses faster hashing (e.g. AES-based) when hardware support is present."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type/interface runtime tables"}),": module/type/linkage structures plus interface dispatch tables (",(0,r.jsx)(n.code,{children:"itabs"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Environment and security checks"}),": parses env vars (including ",(0,r.jsx)(n.code,{children:"GODEBUG=*"}),") and validates stdio fds are open."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GC is prepared but not enabled yet"}),": ",(0,r.jsx)(n.code,{children:"gcinit()"})," sets up GC machinery, but ",(0,r.jsx)(n.code,{children:"gcenable()"})," happens later once the runtime can safely start goroutines/channels."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Then the runtime creates the first \u201creal\u201d goroutine to run ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"runtime.main"})})," (not your ",(0,r.jsx)(n.code,{children:"main"})," yet). In ",(0,r.jsx)(n.code,{children:"runtime.main"}),", it:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Starts the system monitor"})," (",(0,r.jsx)(n.code,{children:"sysmon"}),"): watchdog thread that helps with scheduling fairness, syscalls, GC pacing nudges, etc."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enables GC"})," (",(0,r.jsx)(n.code,{children:"gcenable()"}),"), then runs package ",(0,r.jsx)(n.code,{children:"init()"}),"s in dependency order."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Calls your ",(0,r.jsx)(n.code,{children:"main.main"})]}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["One practical implication: when ",(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"main"})," returns"]}),", the process is exiting; goroutines that are still running are not \u201cgracefully completed\u201d by default. Use explicit synchronization (e.g. ",(0,r.jsx)(n.code,{children:"sync.WaitGroup"}),", context cancellation) if you need work to finish."]}),"\n",(0,r.jsx)(n.h3,{id:"runtime-debug-knobs-worth-remembering",children:"Runtime debug knobs worth remembering"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GODEBUG"})," can emit high-signal traces during startup and runtime:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"GODEBUG=inittrace=1"})}),": timings for package init."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"GODEBUG=schedtrace=1000"})}),": scheduler state every second."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"GODEBUG=gctrace=1"})}),": GC cycle logs."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"memory-allocator-how-heap-memory-is-organized-and-why-its-fast",children:"Memory allocator: how heap memory is organized and why it\u2019s fast"}),"\n",(0,r.jsx)(n.h3,{id:"stack-vs-heap-and-why-the-allocator-matters",children:"Stack vs heap (and why the allocator matters)"}),"\n",(0,r.jsxs)(n.p,{children:["Not all variables go through the allocator. The compiler uses ",(0,r.jsx)(n.strong,{children:"escape analysis"})," to decide what can stay on the stack vs what must live on the heap (e.g. if it outlives the current function call). The allocator manages heap memory and also provides the backing memory for goroutine stacks (even though stack variables themselves are not individually \u201callocated\u201d via the heap allocator)."]}),"\n",(0,r.jsx)(n.h3,{id:"arenas--pages--spans--slots",children:"Arenas \u2192 pages \u2192 spans \u2192 slots"}),"\n",(0,r.jsx)(n.p,{children:"The allocator avoids frequent OS syscalls by requesting memory in large chunks and managing it internally:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Arenas"}),": typically ",(0,r.jsx)(n.strong,{children:"64MB"})," chunks of ",(0,r.jsx)(n.em,{children:"address space"})," reserved from the OS (with OS-level commitment happening incrementally as memory is used)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pages"}),": arenas are subdivided into ",(0,r.jsx)(n.strong,{children:"8KB"})," runtime pages (distinct from typical 4KB OS pages)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Spans"}),": one or more contiguous pages dedicated to objects of a single size (and scan vs noscan category)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Slots"}),": a span is subdivided into fixed-size slots; allocation is often \u201cfind next free slot\u201d."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Spans track allocation state with bitmaps such as:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"allocBits"})}),": which slots are currently allocated."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"gcmarkBits"})}),": which slots were marked live by the GC in the last mark phase."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"After a GC mark phase, the runtime can effectively \u201cfree\u201d dead objects by swapping/interpreting these bitmaps (live remains allocated; unmarked becomes available again)."}),"\n",(0,r.jsx)(n.h3,{id:"size-classes-8b--32kb-and-the-edges",children:"Size classes (8B \u2192 32KB) and the edges"}),"\n",(0,r.jsxs)(n.p,{children:["For ",(0,r.jsx)(n.strong,{children:"small objects (up to ~32KB)"}),", allocations are rounded up to one of ",(0,r.jsx)(n.strong,{children:"68 size classes"}),". This keeps allocation fast and limits fragmentation inside spans."]}),"\n",(0,r.jsx)(n.p,{children:"Two important edge behaviors:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Large objects (> 32KB)"}),": bypass size classes and get their own \u201cclass 0\u201d span sized to the object."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tiny allocator (< 16B, no pointers)"}),": packs multiple tiny, pointer-free objects into a single 16-byte block to reduce waste (so \u201c1-byte things\u201d don\u2019t each consume an 8-byte slot)."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"span-classes-scan-vs-noscan",children:"Span classes (scan vs noscan)"}),"\n",(0,r.jsxs)(n.p,{children:["The allocator separates objects that ",(0,r.jsx)(n.strong,{children:"contain pointers"})," (must be scanned by GC) from those that ",(0,r.jsx)(n.strong,{children:"do not"})," (can be skipped). Combining:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"size class"})," \xd7 ",(0,r.jsx)(n.strong,{children:"(scan|noscan)"})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2026yields ",(0,r.jsx)(n.strong,{children:"136 span classes"})," in total."]}),"\n",(0,r.jsxs)(n.h3,{id:"concurrency-mcache--mcentral--mheap",children:["Concurrency: ",(0,r.jsx)(n.code,{children:"mcache"})," \u2192 ",(0,r.jsx)(n.code,{children:"mcentral"})," \u2192 ",(0,r.jsx)(n.code,{children:"mheap"})]}),"\n",(0,r.jsx)(n.p,{children:"To avoid allocator lock contention under heavy concurrency, Go uses a cache hierarchy:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"mcache"})," (per-",(0,r.jsx)(n.code,{children:"P"}),", fast path, lock-free)"]}),": most allocations are served from a per-processor cache because only one goroutine runs on a ",(0,r.jsx)(n.code,{children:"P"})," at a time."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"mcentral"})," (per span class, briefly locked)"]}),": refills ",(0,r.jsx)(n.code,{children:"mcache"})," with spans when local spans are exhausted."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"mheap"})," (global, expensive/rare path)"]}),": supplies new pages/spans (and may request new arenas from the OS)."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"sweeping-and-scavenging-reclaiming-memory",children:"Sweeping and scavenging: reclaiming memory"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sweeping"}),": spans may be swept lazily \u201con demand\u201d when ",(0,r.jsx)(n.code,{children:"mcentral"})," needs to reuse spans; sweeping interprets GC mark results to find free slots."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scavenging"}),": even after objects are freed, the runtime often keeps pages mapped for reuse. A background scavenger can advise the OS to reclaim physical memory for unused pages (e.g. via ",(0,r.jsx)(n.code,{children:"MADV_DONTNEED"})," on Linux) while keeping address space reserved."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"how-to-apply-this-when-profilingdebugging",children:"How to apply this when profiling/debugging"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If you\u2019re looking at heap growth, allocations, or goroutine state, jump to ",(0,r.jsx)(n.a,{href:"/docs/software/languages/go/profiling-golang-using-pprof",children:(0,r.jsx)(n.code,{children:"pprof.md"})})," for capture/compare commands (including ",(0,r.jsx)(n.code,{children:"heap?gc=1"}),", goroutine dumps, and allocs sampling)."]}),"\n",(0,r.jsxs)(n.li,{children:["If you suspect allocator/GC pressure:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["consider whether objects are ",(0,r.jsx)(n.strong,{children:"tiny"})," (packed), ",(0,r.jsx)(n.strong,{children:"small"})," (size classes), or ",(0,r.jsx)(n.strong,{children:"large"})," (>32KB direct spans),"]}),"\n",(0,r.jsx)(n.li,{children:"and whether your objects contain pointers (scan cost) vs not (noscan)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["If you see \u201cwork still running\u201d at exit, remember that returning from ",(0,r.jsx)(n.code,{children:"main"})," ends the process; coordinate goroutines explicitly."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"sources",children:"Sources"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Internals for Interns \u2014 ",(0,r.jsx)(n.em,{children:"Understanding the Go Runtime: The Bootstrap"}),": ",(0,r.jsx)(n.code,{children:"https://internals-for-interns.com/posts/understanding-go-runtime/"})]}),"\n",(0,r.jsxs)(n.li,{children:["Internals for Interns \u2014 ",(0,r.jsx)(n.em,{children:"Understanding the Go Runtime: The Memory Allocator"}),": ",(0,r.jsx)(n.code,{children:"https://internals-for-interns.com/posts/go-memory-allocator/"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>t});var r=s(96540);const i={},o=r.createContext(i);function a(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);