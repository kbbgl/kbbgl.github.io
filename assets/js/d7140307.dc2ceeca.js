"use strict";(globalThis.webpackChunkkgkb=globalThis.webpackChunkkgkb||[]).push([[30487],{62158:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>l});var s=n(74848),i=n(28453);const t={},c=void 0,r={id:"software/containerization/k8s/api_objects/Objects",title:"Objects",description:"Objects",source:"@site/docs/software/containerization/k8s/api_objects/Objects.md",sourceDirName:"software/containerization/k8s/api_objects",slug:"/software/containerization/k8s/api_objects/Objects",permalink:"/docs/software/containerization/k8s/api_objects/Objects",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"API_Groups",permalink:"/docs/software/containerization/k8s/api_objects/API_Groups"},next:{title:"Working_with_Job_CronJob",permalink:"/docs/software/containerization/k8s/api_objects/Working_with_Job_CronJob"}},d={},l=[{value:"Objects",id:"objects",level:2},{value:"<code>batch</code> API Group",id:"batch-api-group",level:3},{value:"<code>autoscaling</code> API Group,",id:"autoscaling-api-group",level:3},{value:"<code>RBAC</code> API Group",id:"rbac-api-group",level:3}];function a(e){const o={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.h2,{id:"objects",children:"Objects"}),"\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.code,{children:"Node"}),": represents a machine (physical or virtual) that is part of a cluster."]}),"\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.code,{children:"Service Account"}),": Provides an identifier for processes running in a ",(0,s.jsx)(o.code,{children:"Pod"})," to access the API server and performs actions that it is authorized to."]}),"\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.code,{children:"Resource Quota"}),": Allows defining quotas per namespace for limiting resources, e.g. number of ",(0,s.jsx)(o.code,{children:"Pod"}),"s scheduled."]}),"\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.code,{children:"Endpoint"}),": Represents a set of IPs for ",(0,s.jsx)(o.code,{children:"Pod"}),"s that match a particular service."]}),"\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.code,{children:"Deployment"}),": Controller which manages the state of the ",(0,s.jsx)(o.code,{children:"ReplicaSets"})," and the ",(0,s.jsx)(o.code,{children:"Pod"}),"s within."]}),"\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.code,{children:"ReplicaSet"}),": Orchestrates individual ",(0,s.jsx)(o.code,{children:"Pod"})," lifecycle and updates."]}),"\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.code,{children:"Pod"}),": Lowest manageable unit, runs application containers."]}),"\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.code,{children:"DaemonSet"}),": Controller that runs on every node. When a node is added/removed, the controller ensures that the ",(0,s.jsx)(o.code,{children:"Pod"})," is removed from the node as well."]}),"\n",(0,s.jsxs)(o.p,{children:[(0,s.jsx)(o.code,{children:"StatefulSet"}),": ",(0,s.jsx)(o.code,{children:"Pod"}),"s deployed using a ",(0,s.jsx)(o.code,{children:"StatefulSet"})," use the same ",(0,s.jsx)(o.code,{children:"Pod"})," specification. How this is different than a ",(0,s.jsx)(o.code,{children:"Deployment"})," is that a ",(0,s.jsx)(o.code,{children:"StatefulSet"})," considers each Pod as unique and provides ordering to ",(0,s.jsx)(o.code,{children:"Pod"})," deployment."]}),"\n",(0,s.jsxs)(o.h3,{id:"batch-api-group",children:[(0,s.jsx)(o.code,{children:"batch"})," API Group"]}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsxs)(o.li,{children:[(0,s.jsx)(o.code,{children:"Job"}),": Used to run ",(0,s.jsx)(o.code,{children:"Pod"}),"s to completion. If it fails, it will restart until number of completions is reached."]}),"\n",(0,s.jsxs)(o.li,{children:[(0,s.jsx)(o.code,{children:"CronJob"}),": Similar to Linux jobs with the same time syntax."]}),"\n"]}),"\n",(0,s.jsxs)(o.h3,{id:"autoscaling-api-group",children:[(0,s.jsx)(o.code,{children:"autoscaling"})," API Group,"]}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsxs)(o.li,{children:["Horizontal Pod Autoscalers (",(0,s.jsx)(o.strong,{children:"HPA"}),") resources. They automatically scale ",(0,s.jsx)(o.code,{children:"Replication Controllers"}),", ",(0,s.jsx)(o.code,{children:"ReplicaSets"})," or ",(0,s.jsx)(o.code,{children:"Deployments"}),"."]}),"\n",(0,s.jsxs)(o.li,{children:["Cluster Autoscaler (",(0,s.jsx)(o.strong,{children:"CA"}),") adds/removes nodes to the cluster based on inability to deploy ",(0,s.jsx)(o.code,{children:"Pod"}),"s or having nodes with low utilization for at least 10 minutes. When using this type of autoscaler, we use ",(0,s.jsx)(o.code,{children:"cluster-autoscaler"})," commands."]}),"\n"]}),"\n",(0,s.jsxs)(o.h3,{id:"rbac-api-group",children:[(0,s.jsx)(o.code,{children:"RBAC"})," API Group"]}),"\n",(0,s.jsx)(o.p,{children:"Used for access control to API."}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsx)(o.li,{children:(0,s.jsx)(o.code,{children:"ClusterRole"})}),"\n",(0,s.jsx)(o.li,{children:(0,s.jsx)(o.code,{children:"Role"})}),"\n",(0,s.jsx)(o.li,{children:(0,s.jsx)(o.code,{children:"ClusterRoleBinding"})}),"\n",(0,s.jsx)(o.li,{children:(0,s.jsx)(o.code,{children:"RoleBinding"})}),"\n"]})]})}function h(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},28453:(e,o,n)=>{n.d(o,{R:()=>c,x:()=>r});var s=n(96540);const i={},t=s.createContext(i);function c(e){const o=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(t.Provider,{value:o},e.children)}}}]);