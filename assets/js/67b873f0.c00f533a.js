"use strict";(self.webpackChunkkgkb=self.webpackChunkkgkb||[]).push([[24524],{52890:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>o,default:()=>u,frontMatter:()=>d,metadata:()=>c,toc:()=>a});var t=s(74848),r=s(28453);const d={title:"Memory Structures"},o="Memory Structures",c={id:"software/languages/assembly/memory/memory-structures",title:"Memory Structures",description:"We need ways to organize data that makes to us into the machine code. To do this, we use memory structures.",source:"@site/docs/software/languages/assembly/memory/memory-structures.md",sourceDirName:"software/languages/assembly/memory",slug:"/software/languages/assembly/memory/memory-structures",permalink:"/docs/software/languages/assembly/memory/memory-structures",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Memory Structures"},sidebar:"docsSidebar",previous:{title:"Memory Ideas",permalink:"/docs/software/languages/assembly/memory/memory-ideas"},next:{title:"Using Memory",permalink:"/docs/software/languages/assembly/memory/using-memory"}},i={},a=[{value:"<code>struct</code>",id:"struct",level:2},{value:"Nesting Structures",id:"nesting-structures",level:2},{value:"Anonymous Structures",id:"anonymous-structures",level:3},{value:"Unions",id:"unions",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"memory-structures",children:"Memory Structures"})}),"\n",(0,t.jsx)(n.p,{children:"We need ways to organize data that makes to us into the machine code. To do this, we use memory structures."}),"\n",(0,t.jsxs)(n.p,{children:["For example, we could define some point such as a coordinate ",(0,t.jsx)(n.code,{children:"(x, y)"})," using 2 consecutive ",(0,t.jsx)(n.code,{children:"dwords"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"section '.bss' readable writable\n        ; Declare point\n  point:        dd ?\n                dd ?\n       \nsection '.txt' code readable executable\nstart:\n     ; setting x = 3, y = 4\n mov       dword [point]    , 3\n mov       dword [point + 4], 4\n"})}),"\n",(0,t.jsx)(n.p,{children:"But this very messy!"}),"\n",(0,t.jsx)(n.h2,{id:"struct",children:(0,t.jsx)(n.code,{children:"struct"})}),"\n",(0,t.jsxs)(n.p,{children:["We could instead use the ",(0,t.jsx)(n.code,{children:"struct"})," directive to define data structures:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"struct PNT\n x dd ?\n y dd ?\nends\n\nsection '.bss' readable writable\n my_pnt PNT ?\n \nsection '.text' code readable executable\nstart:\n mov    dword [my_pnt.x],3\n mov    dword [my_pnt.y],4\n"})}),"\n",(0,t.jsx)(n.p,{children:"The assembler converts the 2nd way into the 1st way."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Structs can be defined anywhere in the source file but usually is found before sections."}),"\n",(0,t.jsxs)(n.li,{children:["The definitions creates a set of labels which point to memory addresses:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"my_pnt = 0x402000"})," - base address in memory."]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"my_pnt.x = 0x402000"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"my_pnt.y = 0x402004"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"sizeof.my_pnt = 8"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PNT"})," = 0"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PNT.x"})," = 0"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"PNT.y"})," = 4"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["You can define default values for fields of the ",(0,t.jsx)(n.code,{children:"struct"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"struct PNT\n x dd 3\n y dd 4\nends\n"})}),"\n",(0,t.jsxs)(n.p,{children:["So if we wanted to access the ",(0,t.jsx)(n.code,{children:"y"})," field and the size of a structure:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"struct PNT\n x dd ?\n y dd ?\nends\n\nsection '.data' data readable writeable\n ; Declare a point\n my_pnt    PNT   3,4\n end_pnt:\n \nsection '.text' code readable executable\nstart:\n mov eax, dword [my_pnt + PNT.y]\n ; OR\n mov eax, dword [my_pnt.y]\n \n ; getting the size\n mov eax, sizeof.PNT\n \n ; OR\n mov eax, end_pnt - my_pnt\n"})}),"\n",(0,t.jsx)(n.h2,{id:"nesting-structures",children:"Nesting Structures"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"struct PNT\n x dd ?\n y dd ?\nends\n\nstruct CLINE\n color   dd  ?\n p_start PNT ?\n p_end   PNT ?\nends\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"sizeof.CLINE"})," in this case is 4 + 8 + 8 = 20 bytes."]}),"\n",(0,t.jsxs)(n.p,{children:["We use the ",(0,t.jsx)(n.code,{children:"<x,y>"})," brackets to define the nested structure."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"struct PNT\n x dd ?\n y dd ?\nends\n\nstruct CLINE\n color   dd  ?\n p_start PNT ?\n p_end   PNT ?\nends\n\nsection '.data' data readable writeable\n my_line  CLINE 0, <3,4>, <1,5>\n \n \nsection '.text' code readable executable\nstart:\n ; eax == 4\n mov    eax, dword [my_line.color] \n \n ; eax == 3\n mov    eax, dword [my_line.p_start.x]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"anonymous-structures",children:"Anonymous Structures"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"struct DLINE\n struct ;anonymous\n  red     db ?\n  green   db ?\n  blue    db ?\n          db ? ; placeholder\n ends\n p_start PNT ?\n p_end   PNT ?\nends\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this case, ",(0,t.jsx)(n.code,{children:"sizeof.DLINE"})," is 20 bytes == 0x14."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DLINE.red = 0x0"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DLINE.green = 0x1"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"DLINE.p_end = 0xC"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"unions",children:"Unions"}),"\n",(0,t.jsx)(n.p,{children:"Sometimes we need to think about the same chunk of data in more than one way."}),"\n",(0,t.jsxs)(n.p,{children:["For example, we might want to store an IPv4 address as a ",(0,t.jsx)(n.code,{children:"dword"})," but also be able to access each byte separately."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"struct IPv4\n union\n  struct\n   a db ?\n   b db ?\n   c db ?\n   d db ?\n  ends\n  addr dd ?\n ends\nends\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Unions are anonymous. Inside unions, the memory location offset doesn't increase. So ",(0,t.jsx)(n.code,{children:"IPv4.addr"})," and ",(0,t.jsx)(n.code,{children:"IPv4.a"})," both point to the start memory address."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"section '.data' data readable writeable\n lhost     IPv4    <127,0,0,1>\n \nsection '.text' code readable executable\nstart:\n mov     eax, dword [lhost.addr]\n ; eax == 0x0100007f\n \n mov     eax, dword [lhost]\n ; eax == 0x0100007f\n \n mov     bl, byte [lhost.d]\n ; bl == 1\n \n mov     bl, byte [lhost + 3]\n ; bl == 1\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var t=s(96540);const r={},d=t.createContext(r);function o(e){const n=t.useContext(d);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(d.Provider,{value:n},e.children)}}}]);