"use strict";(globalThis.webpackChunkkgkb=globalThis.webpackChunkkgkb||[]).push([[90568],{46803:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var a=t(74848),o=t(28453);const i={},s=void 0,r={id:"software/containerization/kubernetes/Deployments/Deployment_Configuration",title:"Deployment_Configuration",description:"Deployment Configuration",source:"@site/docs/software/containerization/kubernetes/Deployments/Deployment_Configuration.md",sourceDirName:"software/containerization/kubernetes/Deployments",slug:"/software/containerization/kubernetes/Deployments/Deployment_Configuration",permalink:"/docs/software/containerization/kubernetes/Deployments/Deployment_Configuration",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Understanding_Aggregated_APIs",permalink:"/docs/software/containerization/kubernetes/Custom Resource Definitions/Understanding_Aggregated_APIs"},next:{title:"Labels",permalink:"/docs/software/containerization/kubernetes/Deployments/Labels"}},l={},d=[{value:"Deployment Configuration",id:"deployment-configuration",level:2},{value:"Details",id:"details",level:3},{value:"Configuration Metadata",id:"configuration-metadata",level:3},{value:"Configuration Spec",id:"configuration-spec",level:3},{value:"Configuration Pod Template",id:"configuration-pod-template",level:3},{value:"Configuration Status",id:"configuration-status",level:3}];function c(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"deployment-configuration",children:"Deployment Configuration"}),"\n",(0,a.jsx)(n.h3,{id:"details",children:"Details"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1         # not the deployment, but k8s API\nitems:                 # list of items\n- apiVersion: apps/v1  \n  kind: Deployment\n"})}),"\n",(0,a.jsx)(n.h3,{id:"configuration-metadata",children:"Configuration Metadata"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'metadata: \n  annotations:\n    deployment.kubernetes.io/revision: "1"\n  creationTimestamp: 2017-12-21T13:57:07Z\n  generation: 1      # how many times object has been edited\n  labels:            \n    app: dev-web\n  name: dev-web\n  namespace: default\n  resourceVersion: "774003" # tied to etcd to help with concurrent objects\n  selfLink: /apis/apps/v1/namespaces/default/deployments/dev-web # how kube-apiserver will ingest information to API\n  uid: d52d3a63-e656-11e7-9319-42010a800003 # unique ID for the lifecycle of object\n'})}),"\n",(0,a.jsx)(n.h3,{id:"configuration-spec",children:"Configuration Spec"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"spec:  \n  progressDeadlineSeconds: 600  # time until a progress error is reported during a change (e.g. quotas, image issues, limit ranges)\n  replicas: 1  # how many Pods will be created\n  revisionHistoryLimit: 10   # how many old ReplicaSet specs to retain for rollback\n  selector:     \n    matchLabels:      # used to match labels (AND)\n      app: dev-web  \n  strategy:           # control Pod update\n    rollingUpdate:    # how many Pods are deleted at a time with conditions below\n      maxSurge: 25%   # max desired Pods to create. Creates a certain number of Pods before deleting old ones.\n      maxUnavailable: 25%     # max pods that can be in non-ready state\n    type: RollingUpdate # type of strategy chosen\n"})}),"\n",(0,a.jsx)(n.h3,{id:"configuration-pod-template",children:"Configuration Pod Template"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"template: #data passed to replicaset to determine how to deploy object\n  metadata: \n  creationTimestamp: null\n    labels:\n      app: dev-web\n  spec:\n    containers:\n    - image: nginx:1.13.7-alpine\n      imagePullPolicy: IfNotPresent\n      name: dev-web\n      resources: {}\n      terminationMessagePath: /dev/termination-log\n      terminationMessagePolicy: File\n    dnsPolicy: ClusterFirst # DNS query should go to coreDNS (dnsPolicy: ClusterFirst) or node dns server (dnsPolicy: Default)\n    restartPolicy: Always # should container always restart if killed\n    schedulerName: default-scheduler # allows to configure different scheduler\n    securityContext: {} # setting security such as SELinux, AppArmor, etc.\n    terminationGracePeriodSeconds: 30 # amount of time to wait for SIGTERM to run until a SIGKILL is used to terminate container.\n"})}),"\n",(0,a.jsx)(n.h3,{id:"configuration-status",children:"Configuration Status"}),"\n",(0,a.jsxs)(n.p,{children:["Generated when information is requested (",(0,a.jsx)(n.code,{children:"kubectl get deployment -o yaml"}),")"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'status:\n  availableReplicas: 2 # how many replicas were configured by ReplicaSet\n  conditions:\n  - lastTransitionTime: 2017-12-21T13:57:07Z\n    lastUpdateTime: 2017-12-21T13:57:07Z\n    message: Deployment has minimum availability.\n    reason: MinimumReplicasAvailable\n    status: "True"\n    type: Available\n  observedGeneration: 2 # how often deployment has been updated\n  readyReplicas: 2\n  replicas: 2\n  updatedReplicas: 2\n'})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var a=t(96540);const o={},i=a.createContext(o);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);