"use strict";(self.webpackChunkkgkb=self.webpackChunkkgkb||[]).push([[41737],{61662:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>r,metadata:()=>d,toc:()=>a});var o=t(74848),i=t(28453);const r={},s=void 0,d={id:"software/containerization/k8s/Scheduling/Predicates",title:"Predicates",description:"Predicates",source:"@site/docs/software/containerization/k8s/Scheduling/2._Predicates.md",sourceDirName:"software/containerization/k8s/Scheduling",slug:"/software/containerization/k8s/Scheduling/Predicates",permalink:"/docs/software/containerization/k8s/Scheduling/Predicates",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"kube-scheduler",permalink:"/docs/software/containerization/k8s/Scheduling/kube-scheduler"},next:{title:"Priorities",permalink:"/docs/software/containerization/k8s/Scheduling/Priorities"}},c={},a=[{value:"Predicates",id:"predicates",level:2}];function h(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"predicates",children:"Predicates"}),"\n",(0,o.jsx)(n.p,{children:"The scheduler goes through a set of filters, or predicates, to find available nodes, then ranks each node using priority functions. The node with the highest rank is selected to run the Pod."}),"\n",(0,o.jsx)(n.p,{children:"Order of predicates:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"predicatesOrdering = {\n    CheckNodeConditionPred, \n    GeneralPred, \n    HostNamePred, \n    PodFitsHostPortsPred,\n    MatchNodeSelectorPred, \n    PodFitsResourcesPred, \n    NoDiskConflictPred,\n    PodToleratesNodeTaintsPred, \n    PodToleratesNodeNoExecuteTaintsPred,\n    CheckNodeLabelPresencePred, \n    checkServiceAffinityPred,\n    MaxEBSVolumeCountPred, \n    MaxGCEPDVolumeCountPred,\n    MaxAzureDiskVolumeCountPred, \n    CheckVolumeBindingPred,\n    NoVolumeZoneConflictPred, \n    CheckNodeMemoryPressurePred,\n    CheckNodeDiskPressurePred, \n    MatchInterPodAffinityPred\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The predicates, such as ",(0,o.jsx)(n.code,{children:"PodFitsHost"})," or ",(0,o.jsx)(n.code,{children:"NoDiskConflict"}),", are evaluated in a particular and configurable order. In this way, a node has the least amount of checks for new ",(0,o.jsx)(n.code,{children:"Pod"})," deployment, which can be useful to exclude a node from unnecessary checks if the node is not in the proper condition."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, there is a filter called ",(0,o.jsx)(n.code,{children:"HostNamePred"}),", which is also known as ",(0,o.jsx)(n.code,{children:"HostName"}),", which filters out nodes that do not match the node name specified in the pod specification. Another predicate is ",(0,o.jsx)(n.code,{children:"PodFitsResources"})," to make sure that the available CPU and memory can fit the resources required by the Pod."]}),"\n",(0,o.jsxs)(n.p,{children:["The scheduler can be updated by passing a configuration of kind: ",(0,o.jsx)(n.code,{children:"Policy"}),", which can order predicates, give special weights to priorities, and even ",(0,o.jsx)(n.code,{children:"hardPodAffinitySymmetricWeight"}),", which deploys ",(0,o.jsx)(n.code,{children:"Pod"}),"s such that if we set ",(0,o.jsx)(n.code,{children:"Pod"})," A to run with ",(0,o.jsx)(n.code,{children:"Pod"})," B, then ",(0,o.jsx)(n.code,{children:"Pod"})," B should automatically be run with ",(0,o.jsx)(n.code,{children:"Pod"})," A."]})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>d});var o=t(96540);const i={},r=o.createContext(i);function s(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);