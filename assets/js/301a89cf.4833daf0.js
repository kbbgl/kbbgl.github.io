"use strict";(globalThis.webpackChunkkgkb=globalThis.webpackChunkkgkb||[]).push([[94162],{2556:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var t=s(74848),i=s(28453);const a={},o=void 0,l={id:"software/containerization/k8s/Volumes and Data/Persistent_Volumes_and_Claims",title:"Persistent_Volumes_and_Claims",description:"Persistent Volumes and Claims",source:"@site/docs/software/containerization/k8s/Volumes and Data/Persistent_Volumes_and_Claims.md",sourceDirName:"software/containerization/k8s/Volumes and Data",slug:"/software/containerization/k8s/Volumes and Data/Persistent_Volumes_and_Claims",permalink:"/docs/software/containerization/k8s/Volumes and Data/Persistent_Volumes_and_Claims",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Mounting_Secrets_as_Volumes",permalink:"/docs/software/containerization/k8s/Volumes and Data/Mounting_Secrets_as_Volumes"},next:{title:"Secrets",permalink:"/docs/software/containerization/k8s/Volumes and Data/Secrets"}},r={},c=[{value:"Persistent Volumes and Claims",id:"persistent-volumes-and-claims",level:2},{value:"Persistent Volumes",id:"persistent-volumes",level:3},{value:"Persistent Volume Claim",id:"persistent-volume-claim",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"persistent-volumes-and-claims",children:"Persistent Volumes and Claims"}),"\n",(0,t.jsx)(n.h3,{id:"persistent-volumes",children:"Persistent Volumes"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.strong,{children:"persistent volume (pv)"})," is a storage abstraction used to retain data longer than the ",(0,t.jsx)(n.code,{children:"Pod"})," using it. ",(0,t.jsx)(n.code,{children:"Pod"}),"s define a volume of type ",(0,t.jsx)(n.code,{children:"persistentVolumeClaim (pvc)"}),". The cluster then attaches the ",(0,t.jsx)(n.code,{children:"persistentVolume"}),". PVs are not namespaced while PVCs are."]}),"\n",(0,t.jsx)(n.p,{children:"The following are the phases of Persistent Storage:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Provision"}),": Provisioning can be from the PVs created in advance by the cluster administrator or requested from a dynamic provider (Google/AWS, etc)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Bind"}),": Binding occurs when a control loop on the master notices the PVC and locates a matching PV."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Use"}),": When the bound volume is mounted for the ",(0,t.jsx)(n.code,{children:"Pod"})," to use and is kept in this phase as long as the ",(0,t.jsx)(n.code,{children:"Pod"})," requires."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Release"}),": Happens when the ",(0,t.jsx)(n.code,{children:"Pod"})," is done with the volume and an API request to delete the PVC is sent."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Reclaim"}),": could be:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Retain"}),": keeps data intact allowing an admin to handle storage and data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Delete"}),": tells volume plugin to delete the API object as well as storage."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Recycle"}),": run ",(0,t.jsx)(n.code,{children:"rm -rf /mountpoint"})," and then makes it available to a new claim."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"We can see the PV and PVC:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"kubectl get pv\nkubectl get pvc\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The following specification is a basic declaration of a PV using ",(0,t.jsx)(n.code,{children:"hostPath"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: 10Gpv01\n  labels:\n    type: local\nspec:\n  capacity:\n    storage: 10Gi\n  accessModes:\n    - ReadWriteOnce\n  hostPath:\n    path: "/somepath/data01"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"persistent-volume-claim",children:"Persistent Volume Claim"}),"\n",(0,t.jsxs)(n.p,{children:["With a created PV in the cluster, we can write a manifest for a claim and use that claim in the ",(0,t.jsx)(n.code,{children:"Pod"})," specification using ",(0,t.jsx)(n.code,{children:"persistentVolumeClaim"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: myclaim\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 8Gi\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the ",(0,t.jsx)(n.code,{children:"Pod"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"spec:\n  containers:\n...\n  volumes:\n    - name: test-volume\n      persistentVolumeClaim:\n        claimName: myclain\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var t=s(96540);const i={},a=t.createContext(i);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);