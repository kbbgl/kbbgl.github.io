"use strict";(self.webpackChunkkgkb=self.webpackChunkkgkb||[]).push([[90007],{10074:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>h});var s=t(74848),r=t(28453);const o={slug:"dealing-with-threads",title:"Dealing with Threads",author:["kbbgl"],tags:["go","concurrency","threads"]},a=void 0,i={id:"software/languages/go/concurrency/dealing_with_threads",title:"Dealing with Threads",description:"The OS gives us various tools to help manage concurrency. Two of them, processes and threads are used in our code. A process represents a program that is running on the system. A thread is a construct that executes within the process context to give a lightweight and  efficient approach to concurrency. A process is started with one, main thread. Processes do not share memory and therefore minimize communication with other processes.",source:"@site/docs/software/languages/go/concurrency/2_dealing_with_threads.md",sourceDirName:"software/languages/go/concurrency",slug:"/software/languages/go/concurrency/dealing-with-threads",permalink:"/docs/software/languages/go/concurrency/dealing-with-threads",draft:!1,unlisted:!1,tags:[{inline:!0,label:"go",permalink:"/docs/tags/go"},{inline:!0,label:"concurrency",permalink:"/docs/tags/concurrency"},{inline:!0,label:"threads",permalink:"/docs/tags/threads"}],version:"current",sidebarPosition:2,frontMatter:{slug:"dealing-with-threads",title:"Dealing with Threads",author:["kbbgl"],tags:["go","concurrency","threads"]},sidebar:"docsSidebar",previous:{title:"Foundations",permalink:"/docs/software/languages/go/concurrency/foundations"},next:{title:"Thread Communication",permalink:"/docs/software/languages/go/concurrency/thread-communication"}},c={},h=[{value:"Concurrency with Processes",id:"concurrency-with-processes",level:3},{value:"Concurrency with Threads",id:"concurrency-with-threads",level:3},{value:"Creating goroutines",id:"creating-goroutines",level:3},{value:"Implementing goroutines in user-space",id:"implementing-goroutines-in-user-space",level:3},{value:"Concurrency vs parallelism",id:"concurrency-vs-parallelism",level:3}];function l(e){const n={a:"a",code:"code",h3:"h3",li:"li",ol:"ol",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The OS gives us various tools to help manage concurrency. Two of them, ",(0,s.jsx)(n.strong,{children:"processes"})," and ",(0,s.jsx)(n.strong,{children:"threads"})," are used in our code. A process represents a program that is running on the system. A thread is a construct that executes within the process context to give a lightweight and  efficient approach to concurrency. A process is started with one, main thread. Processes do not share memory and therefore minimize communication with other processes."]}),"\n",(0,s.jsxs)(n.p,{children:["When we run a command such as ",(0,s.jsx)(n.code,{children:"grep hello large_readme.md"}),", the following things happen:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The user submits input for execution."}),"\n",(0,s.jsx)(n.li,{children:"The OS places the job in the job queue."}),"\n",(0,s.jsx)(n.li,{children:"Once the job is ready to execute, it is moved to the ready/run queue."}),"\n",(0,s.jsx)(n.li,{children:"When the CPU frees up, the OS picks up the job from the ready queue and starts executing it on the CPU. The processor is running the instructions contained in the job."}),"\n",(0,s.jsx)(n.li,{children:"As soon as the job requests an instruction to read from a file, the OS removes the job from the CPU onto an I/O waiting queue. It waits here until the requested I/O op returns data. If there's another job in the ready queue, the OS picks it up and executes it on the CPU."}),"\n",(0,s.jsx)(n.li,{children:"The device will complete the read bytes from text file  I/O operation."}),"\n",(0,s.jsx)(n.li,{children:"Once the I/O operation is complete, the job moves back to the ready queue. It waits for the OS to pick it up so that it can continue execution."}),"\n",(0,s.jsx)(n.li,{children:"When the CPU frees up, the OS picks up the job and continues execution instructions on the CPU (try to find match in file text)."}),"\n",(0,s.jsxs)(n.li,{children:["The system might raise an interrupt while the job is in execution. An ",(0,s.jsx)(n.strong,{children:"interrupt"})," is a mechanism used to stop current execution and notify the system of a particular event. This is handled by the interrupt controller."]}),"\n",(0,s.jsx)(n.li,{children:"The OS pauses execution of current job and puts the job back on the ready queue. The job of the OS scheduling algorithm is to determined which job from the ready queue to pick up for execution."}),"\n",(0,s.jsx)(n.li,{children:"Steps 4-9 will repeat until the job execution finishes."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Steps 9 and 10 are an example of ",(0,s.jsx)(n.strong,{children:"context switch"})," which occurs whenever the system interrupts a job and the OS steps in to schedule another one. The OS saves the current job state so it can resume where it left off and also load the next job to be executed. This state is referred to as the ",(0,s.jsx)(n.strong,{children:"process context block"})," and is a data structure used to store all the details about a job."]}),"\n",(0,s.jsx)(n.h3,{id:"concurrency-with-processes",children:"Concurrency with Processes"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"CreateProcess()"})," on Windows or ",(0,s.jsx)(n.code,{children:"fork()"})," on UNIX systems are syscalls that create a copy of an execution. They create the child process, allocate the required resources and loads the program code. The OS also makes a complete copy of the memory space, the process' resource handlers (registers, stack, file handlers, program counter). The new process then takes over this new memory space and continues execution from that point."]}),"\n",(0,s.jsxs)(n.p,{children:["Support for creating and forking processes in Go is limited to the ",(0,s.jsx)(n.code,{children:"syscall"})," package and is OS-specific. We find the ",(0,s.jsx)(n.code,{children:"CreateProcess"})," function for Windows and ",(0,s.jsx)(n.code,{children:"ForkExec"}),"/",(0,s.jsx)(n.code,{children:"StartProcess"})," for UNIX."]}),"\n",(0,s.jsx)(n.p,{children:"Processes also do not share memory space."}),"\n",(0,s.jsx)(n.h3,{id:"concurrency-with-threads",children:"Concurrency with Threads"}),"\n",(0,s.jsx)(n.p,{children:"Creating a new process is resource-heavy and provides good isolation. Threads are the answer to some of the problems that come with using processes for concurrency. Creating a thread is much faster (can reach x100) and it consumes much less resources than a process."}),"\n",(0,s.jsx)(n.p,{children:"Threads share memory space and run within the context of the same process. This means that if a change is made in the main memory by one thread (e.g. changing a global variable's value), this change is visible to all other threads. This is the main advantage of using threads, multiple threads can use this shared memory to work on the same problem together. Threads do not share stack space so local variables are only visible to the thread that created them. They also have their own instruction pointer."}),"\n",(0,s.jsx)(n.p,{children:"There's no isolation so threads can overstep each other. To prevent this, we use thread communication and synchronization."}),"\n",(0,s.jsxs)(n.p,{children:["In Windows, we can create a thread using ",(0,s.jsx)(n.code,{children:"CreateThread()"})," syscall. In UNIX, we use the ",(0,s.jsx)(n.code,{children:"clone()"})," syscall with the ",(0,s.jsx)(n.code,{children:"CLONE_THREAD"})," option. Java models threads as objects, Python blocks multiple threads from executing in parallel using a global interpreter lock and Go has the concept of the goroutine."]}),"\n",(0,s.jsx)(n.p,{children:"goroutines give us a lightweight construct, consuming far fewer resources than the OS thread."}),"\n",(0,s.jsx)(n.h3,{id:"creating-goroutines",children:"Creating goroutines"}),"\n",(0,s.jsxs)(n.p,{children:["Suppose we have the ",(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(67781).A+"",children:(0,s.jsx)(n.code,{children:"sequential.go"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To put perform ",(0,s.jsx)(n.code,{children:"doWork()"})," concurrently we put it in a goroutine as in ",(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(95077).A+"",children:(0,s.jsx)(n.code,{children:"parallel.go"})}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"implementing-goroutines-in-user-space",children:"Implementing goroutines in user-space"}),"\n",(0,s.jsx)(n.p,{children:"Instead of implementing threads at the kernel leve, we can have threads running\ncompletely in user space. This means that the memory space that is part of our\napplication. Using user-level threads is like having different threads of\nexecution running inside the main kernel-level thread."}),"\n",(0,s.jsx)(n.p,{children:"A process containing user-level threads will appear to have\njust one thread of execution. The process is responsible for\nmanaging, scheduling and context switching its own user-level threads."}),"\n",(0,s.jsx)(n.p,{children:"Go provides a hybrid system that gives us the great performance of user-level threads\nwithout most of the downsides. It achieves this by using a set of kernel-level threads\neach managing a queue of goroutines."}),"\n",(0,s.jsxs)(n.p,{children:["Go's runtime determines how many kernel-level threads\nto use based on the number of logical processors. This is set by env var ",(0,s.jsx)(n.code,{children:"GOMAXPROCS"})," which is by default the number of CPUs\nthe system has."]}),"\n",(0,s.jsxs)(n.p,{children:["Go's runtime will assign a ",(0,s.jsx)(n.strong,{children:"local run queue"})," (LRQ) for each kernel-level thread.\nEach LRQ will contain a subset of goroutines in the program. There's also a ",(0,s.jsx)(n.strong,{children:"global run queue"})," (GRQ)\nfor goroutines that Go hasn't assigned yet to a kernel-level thread.\nEach kernel-level thread will execute the goroutines present in its LRQ.\nThe system of moving goroutines from one queue to another is known in Go as ",(0,s.jsx)(n.strong,{children:"work stealing"}),". Its there to overcome blocking I/O calls and balancing work across processors."]}),"\n",(0,s.jsxs)(n.p,{children:["We can force a goroutine to lock itself to an OS thread by calling ",(0,s.jsx)(n.code,{children:"runtime.LockOSThread()"})," and ",(0,s.jsx)(n.code,{children:"runtime.UnlockOSThread()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We can call the ",(0,s.jsx)(n.code,{children:"runtime.Gosched()"})," after ",(0,s.jsx)(n.code,{children:"go sayHello()"})," as seen in ",(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(54016).A+"",children:(0,s.jsx)(n.code,{children:"scheduler.go"})}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"concurrency-vs-parallelism",children:"Concurrency vs parallelism"}),"\n",(0,s.jsx)(n.p,{children:"Concurrency is an attribute of the program code while parallelism is a property of the executing program.\nConcurrent is about planning how to do many tasks at the same time. Parallelism is about performing many tasks at the same time."})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},95077:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/files/parallel-5744ad5b5c1a9ea8b384599e039d5938.go"},54016:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/files/scheduler-7c52b77bee0e3fd0d58923ce62802b82.go"},67781:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/files/sequential-1a509e3adc997f5d16c199bac3c09795.go"},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(96540);const r={},o=s.createContext(r);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);