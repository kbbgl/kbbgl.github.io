"use strict";(globalThis.webpackChunkkgkb=globalThis.webpackChunkkgkb||[]).push([[66973],{57754:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var t=n(74848),a=n(28453);const o={slug:"encoding",title:"Encoding",description:"Chapter 4 from Designing Data Intensive Applications",authors:["kbbgl"],tags:["scalability","system","design","encoding","architecture"]},i=void 0,r={id:"software/system_design/encoding",title:"Encoding",description:"Chapter 4 from Designing Data Intensive Applications",source:"@site/docs/software/system_design/4_encoding.md",sourceDirName:"software/system_design",slug:"/software/system_design/encoding",permalink:"/docs/software/system_design/encoding",draft:!1,unlisted:!1,tags:[{inline:!0,label:"scalability",permalink:"/docs/tags/scalability"},{inline:!0,label:"system",permalink:"/docs/tags/system"},{inline:!0,label:"design",permalink:"/docs/tags/design"},{inline:!0,label:"encoding",permalink:"/docs/tags/encoding"},{inline:!0,label:"architecture",permalink:"/docs/tags/architecture"}],version:"current",sidebarPosition:4,frontMatter:{slug:"encoding",title:"Encoding",description:"Chapter 4 from Designing Data Intensive Applications",authors:["kbbgl"],tags:["scalability","system","design","encoding","architecture"]},sidebar:"docsSidebar",previous:{title:"Storage and Retrieval",permalink:"/docs/software/system_design/storage-retrieval"},next:{title:"Run diff with specific lines to ignore",permalink:"/docs/software/version_control_systems/diff-files-ignore-lines"}},c={},d=[{value:"Formats",id:"formats",level:2},{value:"Schema Evolution",id:"schema-evolution",level:3},{value:"Modes of Data Flow",id:"modes-of-data-flow",level:2}];function l(e){const s={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"When a schema or document structure is changes as part of introducing new features. Encoding data using JSON, XML, Protocol Buffers support systems where old and new data and code need to coexist. These formats are also used for data storage and communication of web services, REST, RPCs and queues."}),"\n",(0,t.jsx)(s.h2,{id:"formats",children:"Formats"}),"\n",(0,t.jsxs)(s.p,{children:["Applications work with data either ",(0,t.jsx)(s.strong,{children:"in memory"})," (objects, structs, trees, etc.) or, when writing data to a file or sending it over the network, the data is ",(0,t.jsx)(s.strong,{children:"encoded"})," in some self-contained sequence of bytes."]}),"\n",(0,t.jsxs)(s.p,{children:["The translation from in-memory to byte sequence is called ",(0,t.jsx)(s.strong,{children:"encoding/serialization/marshalling"}),". Going from byte sequence to in-memory is called ",(0,t.jsx)(s.strong,{children:"decoding/parsing/deserialization/unmarshalling"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"JSON, XML"})," are now the standard but are textual, verbose and therefore large. ",(0,t.jsx)(s.strong,{children:"Binary encoding"})," libraries such as Thrift and Protocol Buffers (protobuf) can decrease the size. Both require a schema describing the encoded payload and include a code generation tool that takes the schema definition and produces classes that implement the schema in different programming languages."]}),"\n",(0,t.jsx)(s.p,{children:"For example, a JSON payload like this:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-json",children:'{\n    "userName": "kbbgl",\n    "id": 1337,\n    "clubs": ["Boca Juniors", "Arsenal"]\n}\n'})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-protobuf",children:"message Person {\n    required string user_name       = 1;\n    optional int64  id              = 2;\n    repeated string clubs           = 3;\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"Apache Avro actually has the best compression."}),"\n",(0,t.jsx)(s.h3,{id:"schema-evolution",children:"Schema Evolution"}),"\n",(0,t.jsx)(s.p,{children:"As schemas change, we need to make sure to maintain compatibility."}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"We can make changes to field names but not tags (1, 2, 3)."}),"\n",(0,t.jsx)(s.li,{children:"We can add new fields to the schema by giving it a new tag. You cannot make it a required field though. It needs to be optional or have a default value."}),"\n",(0,t.jsx)(s.li,{children:"We can remove a field only if it's optional and you cannot reuse the same tag number."}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"modes-of-data-flow",children:"Modes of Data Flow"}),"\n",(0,t.jsxs)(s.p,{children:["To send some data to another process which you don't share memory with, such as sending data over a network to write it to a file, we need to encode it as a sequence of bytes. ",(0,t.jsx)(s.strong,{children:"The most common ways for how data flows between processes is using databases, service calls and async message passing"}),"."]}),"\n",(0,t.jsx)(s.p,{children:"In case of databases, the process that writes to the database encodes the data and the process that reads from the database decodes it."}),"\n",(0,t.jsx)(s.p,{children:"In case of service calls, the most common way is to use clients and servers using REST. Services expose an application-specific API that only allows outputs and inputs predetermined by the business logic."}),"\n",(0,t.jsxs)(s.p,{children:["RPCs are also popular and work on the idea that network requests and local function calls are similar (which they are not). gRPC is a popular RPC and builds on the Protocol Buffers implementation. gRPC supports ",(0,t.jsx)(s.strong,{children:"streams"}),", a call consists of not just one request/response but a series of them over time. RPCs are mostly used for communication within microservices running on the same system network."]}),"\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.strong,{children:"Asynchronous message-passing systems"})," are somewhere between databases and RPCs.\nA client request (a ",(0,t.jsx)(s.strong,{children:"message"}),") is delivered to another process passing through a ",(0,t.jsx)(s.strong,{children:"message broker/queue"}),". The sender doesn't wait for the message to be delivered.\nMessage brokers have one process, the ",(0,t.jsx)(s.strong,{children:"publisher"}),", send a message to a name queue or topic, and the broker ensures that the message is delivered to one or more ",(0,t.jsx)(s.strong,{children:"consumers/subscribers"}),"."]}),"\n",(0,t.jsx)(s.p,{children:"Using a message queue is more reliable than RPCs."}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.strong,{children:"actor model"})," is a design pattern for concurrency in a single process. Actors are usually an instance of the system which has some logic and state within it and it communicates with other actors by sending/receiving async messages. In this case, there's no need to encode and decode the messages since it's an IPC.\nThere's also the ",(0,t.jsx)(s.strong,{children:"distributed actor framework"})," where the actors are spread across different nodes so the messages are encoded/decoded before and after the message is sent over the network."]})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>r});var t=n(96540);const a={},o=t.createContext(a);function i(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);