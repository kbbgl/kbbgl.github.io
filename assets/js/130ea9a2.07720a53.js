"use strict";(self.webpackChunkkgkb=self.webpackChunkkgkb||[]).push([[45061],{38999:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var t=s(74848),o=s(28453);const i={},r=void 0,c={id:"software/containerization/k8s/Security/Network_Security_Policies",title:"Network_Security_Policies",description:"Network Security Policies",source:"@site/docs/software/containerization/k8s/Security/7._Network_Security_Policies.md",sourceDirName:"software/containerization/k8s/Security",slug:"/software/containerization/k8s/Security/Network_Security_Policies",permalink:"/docs/software/containerization/k8s/Security/Network_Security_Policies",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Pod_Security_Policies",permalink:"/docs/software/containerization/k8s/Security/Pod_Security_Policies"},next:{title:"Overview",permalink:"/docs/software/containerization/k8s/Services/Overview"}},a={},l=[{value:"Network Security Policies",id:"network-security-policies",level:2},{value:"Network Security Example",id:"network-security-example",level:3},{value:"Default Policy Example",id:"default-policy-example",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"network-security-policies",children:"Network Security Policies"}),"\n",(0,t.jsxs)(n.p,{children:["By default, all ",(0,t.jsx)(n.code,{children:"Pod"}),"s can reach each other; all ingress and egress traffic is allowed. This has been a high-level networking requirement in Kubernetes. However, network isolation can be configured and traffic to ",(0,t.jsx)(n.code,{children:"Pod"}),"s can be blocked. In newer versions of Kubernetes, egress traffic can also be blocked. This is done by configuring a ",(0,t.jsx)(n.code,{children:"NetworkPolicy"}),". As all traffic is allowed, you may want to implement a policy that drops all traffic, then, other policies which allow desired ingress and egress traffic."]}),"\n",(0,t.jsxs)(n.p,{children:["The spec of the policy can narrow down the effect to a particular namespace, which can be handy. Further settings include a ",(0,t.jsx)(n.code,{children:"podSelector"}),", or ",(0,t.jsx)(n.code,{children:"label"}),", to narrow down which ",(0,t.jsx)(n.code,{children:"Pod"}),"s are affected. Further ingress and egress settings declare traffic to and from IP addresses and ports."]}),"\n",(0,t.jsxs)(n.p,{children:["Not all network providers support the ",(0,t.jsx)(n.code,{children:"NetworkPolicies"})," kind. A non-exhaustive list of providers with support includes Calico, Romana, Cilium, Kube-router, and WeaveNet."]}),"\n",(0,t.jsxs)(n.p,{children:["In previous versions of Kubernetes, there was a requirement to annotate a namespace as part of network isolation, specifically the ",(0,t.jsx)(n.code,{children:"net.beta.kubernetes.io/network-policy="})," value. Some network plugins may still require this setting."]}),"\n",(0,t.jsx)(n.h3,{id:"network-security-example",children:"Network Security Example"}),"\n",(0,t.jsxs)(n.p,{children:["The use of policies has become stable, noted with the ",(0,t.jsx)(n.code,{children:"v1 apiVersion"}),". The example below narrows down the policy to affect the default namespace."]}),"\n",(0,t.jsxs)(n.p,{children:["Only ",(0,t.jsx)(n.code,{children:"Pod"}),"s with the ",(0,t.jsx)(n.code,{children:"label"})," of ",(0,t.jsx)(n.code,{children:"role: db"})," will be affected by this policy, and the policy has both ",(0,t.jsx)(n.code,{children:"Ingress"})," and ",(0,t.jsx)(n.code,{children:"Egress"})," settings."]}),"\n",(0,t.jsxs)(n.p,{children:["The ingress setting includes a ",(0,t.jsx)(n.code,{children:"172.17"})," network, with a smaller range of ",(0,t.jsx)(n.code,{children:"172.17.1.0"})," IPs being excluded from this traffic."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: ingress-egress-policy\n  namespace: default\nspec:\n  podSelector:\n    matchLabels:\n      role: db\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - ipBlock:\n        cidr: 172.17.0.0/16\n        except:\n        - 172.17.1.0/24\n  - namespaceSelector:\n      matchLabels:\n        project: myproject\n  - podSelector:\n      matchLabels:\n        role: frontend\n  ports:\n  - protocol: TCP\n    port: 6379\negress:\n- to:\n  - ipBlock:\n      cidr: 10.0.0.0/24\n  ports:\n  - protocol: TCP\n    port: 5978\n"})}),"\n",(0,t.jsxs)(n.p,{children:["These rules change the namespace for the following settings to be labeled ",(0,t.jsx)(n.code,{children:"project: myproject"}),". The affected ",(0,t.jsx)(n.code,{children:"Pod"}),"s also would need to match the label ",(0,t.jsx)(n.code,{children:"role: frontend"}),". Finally, TCP traffic on port ",(0,t.jsx)(n.code,{children:"6379"})," would be allowed from these ",(0,t.jsx)(n.code,{children:"Pod"}),"s."]}),"\n",(0,t.jsxs)(n.p,{children:["The egress rules have the ",(0,t.jsx)(n.code,{children:"to"})," settings, in this case the ",(0,t.jsx)(n.code,{children:"10.0.0.0/24"})," range TCP traffic to port ",(0,t.jsx)(n.code,{children:"5978"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The use of empty ingress or egress rules denies all type of traffic for the included Pods, though this is not suggested. Use another dedicated ",(0,t.jsx)(n.code,{children:"NetworkPolicy"})," instead."]}),"\n",(0,t.jsxs)(n.p,{children:["Note that there can also be complex ",(0,t.jsx)(n.code,{children:"matchExpressions"})," statements in the spec, but this may change as ",(0,t.jsx)(n.code,{children:"NetworkPolicy"})," matures."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'podSelector:\n  matchExpressions:\n    - {key: inns, operator: In, values: ["yes"]}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["More ",(0,t.jsx)(n.a,{href:"https://github.com/ahmetb/kubernetes-network-policy-recipes",children:"network policy recipes can be found on GitHub"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"default-policy-example",children:"Default Policy Example"}),"\n",(0,t.jsxs)(n.p,{children:["The empty braces will match all ",(0,t.jsx)(n.code,{children:"Pod"}),"s not selected by other ",(0,t.jsx)(n.code,{children:"NetworkPolicy"})," and will not allow ingress traffic. Egress traffic would be unaffected by this policy."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny\nspec:\n  podSelector: {}\n  policyTypes:\n  - Ingress\n"})}),"\n",(0,t.jsx)(n.p,{children:"With the potential for complex ingress and egress rules, it may be helpful to create multiple objects which include simple isolation rules and use easy to understand names and labels."}),"\n",(0,t.jsxs)(n.p,{children:["Some network plugins, such as WeaveNet, may require annotation of the ",(0,t.jsx)(n.code,{children:"Namespace"}),". The following shows the setting of a ",(0,t.jsx)(n.code,{children:"DefaultDeny"})," for the ",(0,t.jsx)(n.code,{children:"myns"})," namespace:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'kind: Namespace\napiVersion: v1\nmetadata:\n  name: myns\n  annotations:\n    net.beta.kubernetes.io/network-policy: |\n     {\n        "ingress": {\n          "isolation": "DefaultDeny"\n        }\n     }\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var t=s(96540);const o={},i=t.createContext(o);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);