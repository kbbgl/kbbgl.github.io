"use strict";(self.webpackChunkkgkb=self.webpackChunkkgkb||[]).push([[7092],{30580:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>o});var i=s(74848),a=s(28453);const r={},t="Handling Failures in Pipes",c={id:"software/languages/bash/pipefail",title:"Handling Failures in Pipes",description:"Source",source:"@site/docs/software/languages/bash/pipefail.md",sourceDirName:"software/languages/bash",slug:"/software/languages/bash/pipefail",permalink:"/docs/software/languages/bash/pipefail",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Multiprocessing in Bash Scripts",permalink:"/docs/software/languages/bash/multiprocessing"},next:{title:"Read CSV In Terminal",permalink:"/docs/software/languages/bash/read_csv"}},l={},o=[{value:"Using <code>set -e</code>",id:"using-set--e",level:2},{value:"Failures in Pipes",id:"failures-in-pipes",level:2},{value:"Catching Uninitialized Variables",id:"catching-uninitialized-variables",level:2},{value:"Print Command and Parameters using <code>set -x</code>",id:"print-command-and-parameters-using-set--x",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"handling-failures-in-pipes",children:"Handling Failures in Pipes"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://www.howtogeek.com/782514/how-to-use-set-and-pipefail-in-bash-scripts-on-linux/",children:"Source"})}),"\n",(0,i.jsxs)(n.h2,{id:"using-set--e",children:["Using ",(0,i.jsx)(n.code,{children:"set -e"})]}),"\n",(0,i.jsxs)(n.p,{children:["When there is no pipe but just a sequence of commands, we can use ",(0,i.jsx)(n.code,{children:"set -e"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"#!/bin/bash\n\n# This will ensure that the script exists\n# if any command fails and return code is non-zero\nset -e\n\necho This will happen\nls some_file\necho This will not happen\n"})}),"\n",(0,i.jsx)(n.h2,{id:"failures-in-pipes",children:"Failures in Pipes"}),"\n",(0,i.jsxs)(n.p,{children:["The return code in a sequence of piped commands is the last one. So if one of the piped commands fails but the last command succeeds, we will erroneously get back a ",(0,i.jsx)(n.code,{children:"0"})," return code and dependent scripts will continue execution."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, if we pipe a ",(0,i.jsx)(n.code,{children:"false"})," (which returns a non-zero code) into ",(0,i.jsx)(n.code,{children:"true"})," (which returns a zero code), we will get a ",(0,i.jsx)(n.code,{children:"0"})," return code:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"> false | true\n\n> echo $?\n0\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Bash has an array variable called ",(0,i.jsx)(n.code,{children:"PIPESTATUS"})," which captures all of the return codes from each program in the pipe chain:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'> false | true | false | true\n\n> echo "${PIPESTATUS[0]} ${PIPESTATUS[1]} ${PIPESTATUS[2]} ${PIPESTATUS[3]}"\n1 0 1 0\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"PIPESTATUS"})," only holds the return codes until the next program runs, and trying to determine which return code goes with which program can get very messy very quickly."]}),"\n",(0,i.jsxs)(n.p,{children:["This is where ",(0,i.jsx)(n.code,{children:"set -o"})," (options) and ",(0,i.jsx)(n.code,{children:"pipefail"})," come in."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"set -eo pipefail\n\necho This will happen first\ncat script-99.sh | wc -l\necho This will not be printed\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This will return a ",(0,i.jsx)(n.code,{children:"1"})," and will not execute the second ",(0,i.jsx)(n.code,{children:"echo"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"catching-uninitialized-variables",children:"Catching Uninitialized Variables"}),"\n",(0,i.jsxs)(n.p,{children:["Uninitialized variables can be difficult to spot in a real-world script. If we try to ",(0,i.jsx)(n.code,{children:"echo"})," the value of an uninitialized variable, ",(0,i.jsx)(n.code,{children:"echo"})," simply prints a blank line. It doesn\u2019t raise an error message. The rest of the script will continue to execute."]}),"\n",(0,i.jsxs)(n.p,{children:["We can trap this type of error using the ",(0,i.jsx)(n.code,{children:"set -u"})," (unset) option."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash \n\nset -eou pipefail\n\necho "$notset" \necho "Another echo command"\n\n# notset: unbound variable\n# echo $?\n# 1\n'})}),"\n",(0,i.jsx)(n.p,{children:"If we want to initialize a value:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash \n\nset -euo pipefail\n\nif [ -z "${New_Var:-}" ]; then \n echo "New_Var has no value assigned to it." \nfi\n'})}),"\n",(0,i.jsxs)(n.h2,{id:"print-command-and-parameters-using-set--x",children:["Print Command and Parameters using ",(0,i.jsx)(n.code,{children:"set -x"})]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>c});var i=s(96540);const a={},r=i.createContext(a);function t(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);