"use strict";(self.webpackChunkkgkb=self.webpackChunkkgkb||[]).push([[60579],{63869:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>a,metadata:()=>i,toc:()=>h});var t=o(74848),r=o(28453);const a={slug:"thread-communication",title:"Thread Communication",author:["kbbgl"],tags:["go","concurrency","threads"]},s=void 0,i={id:"software/languages/go/concurrency/thread_communication",title:"Thread Communication",description:"Threads working together require some form of communication.",source:"@site/docs/software/languages/go/concurrency/3_thread_communication.md",sourceDirName:"software/languages/go/concurrency",slug:"/software/languages/go/concurrency/thread-communication",permalink:"/docs/software/languages/go/concurrency/thread-communication",draft:!1,unlisted:!1,tags:[{inline:!0,label:"go",permalink:"/docs/tags/go"},{inline:!0,label:"concurrency",permalink:"/docs/tags/concurrency"},{inline:!0,label:"threads",permalink:"/docs/tags/threads"}],version:"current",sidebarPosition:3,frontMatter:{slug:"thread-communication",title:"Thread Communication",author:["kbbgl"],tags:["go","concurrency","threads"]},sidebar:"docsSidebar",previous:{title:"Dealing with Threads",permalink:"/docs/software/languages/go/concurrency/dealing-with-threads"},next:{title:"Using Delve Debugger",permalink:"/docs/software/languages/go/how-to-debug-go-code-delve"}},c={},h=[{value:"Memory Sharing",id:"memory-sharing",level:2},{value:"Sharing a Variable between goroutines",id:"sharing-a-variable-between-goroutines",level:3},{value:"Updating shared variables from multiple goroutines",id:"updating-shared-variables-from-multiple-goroutines",level:3},{value:"Race Conditions",id:"race-conditions",level:4},{value:"Solving Race Conditions",id:"solving-race-conditions",level:4},{value:"Detecting Race Conditions",id:"detecting-race-conditions",level:4}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Threads working together require some form of communication.\nThere are ",(0,t.jsx)(n.strong,{children:"inter-thread communications"})," (ITC) and ",(0,t.jsx)(n.strong,{children:"inter-process communications"})," (IPC).\nThis type of communication falls under two main classes:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#memory-sharing",children:"Memory sharing"})," is similar to talking to a person through a whiteboard."]}),"\n",(0,t.jsx)(n.li,{children:"Message passing is similar to talking to a person through sending messages."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"memory-sharing",children:"Memory Sharing"}),"\n",(0,t.jsx)(n.p,{children:"All executions share the process' memory where each execution gets to write the results\nof its own computation. We can coordinate the executions so that they collaborate\nusing the process' memory."}),"\n",(0,t.jsx)(n.p,{children:"The memory sharing involves a few layers:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"main process memory."}),"\n",(0,t.jsx)(n.li,{children:"system bus."}),"\n",(0,t.jsx)(n.li,{children:"cache"}),"\n",(0,t.jsx)(n.li,{children:"CPU + threads"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In a scenario where a thread wants to read data from a memory location (the process' main memory),\nthe CPU requests data in the system bus. the system bus forwards the request\nto the main memory. The entire memory block is read from the main memory and is placed on the bus.\nThe bus puts the memory in cache so it's closer to the CPU. The CPU uses this cache every time it needs to\naccess the same data."}),"\n",(0,t.jsxs)(n.p,{children:["In a scenario where thread 1 updates a variable and thread 2 wants to read this updated value, thread 1\nupdates the variable in cache memory. A ",(0,t.jsx)(n.strong,{children:"write-through"})," occurs where the cache line is flushed to main.\nThe cache line is placed on the bus and the main memory is updated from the bus.\nThe cache listens to the bus for updates and invalidates the cache line if it detects\nthe update. Then the CPU where thread 2 lives reads the updated variable."]}),"\n",(0,t.jsx)(n.h3,{id:"sharing-a-variable-between-goroutines",children:"Sharing a Variable between goroutines"}),"\n",(0,t.jsxs)(n.p,{children:["To share a variable between goroutines, we pass the variable's memory address (using ",(0,t.jsx)(n.code,{children:"&variable"}),")\nto the function that will run in the goroutine. In the function, we dereference and set the variable.\nThen we can reference the variable which will have the updated value after the function run in the goroutine\nfinishes executing."]}),"\n",(0,t.jsxs)(n.p,{children:["When we execute the ",(0,t.jsx)(n.code,{children:"countdown()"})," function in a separate (from the main goroutine) goroutine,\nthe Go compiler realizes that we are sharing memory between goroutines and allocates\nmemory on the heap (instead of the stack). This is called ",(0,t.jsx)(n.strong,{children:"escaping"}),". Heap memory is used by all\nparts of the process whereas stack memory is used only by one thread."]}),"\n",(0,t.jsxs)(n.p,{children:["See ",(0,t.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:o(66313).A+"",children:(0,t.jsx)(n.code,{children:"countdown.go"})})," for an example."]}),"\n",(0,t.jsx)(n.p,{children:"We can tell a variable has escaped to heap memory by asking the compiler to show its optimization\ndecisions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"go tool compile -m countdown.go\n"})}),"\n",(0,t.jsx)(n.h3,{id:"updating-shared-variables-from-multiple-goroutines",children:"Updating shared variables from multiple goroutines"}),"\n",(0,t.jsx)(n.p,{children:"To share variables between multiple goroutines, all we need to do is pass the variable that we want to manipulate into the function that is being run in the goroutine."}),"\n",(0,t.jsxs)(n.p,{children:["In [",(0,t.jsx)(n.code,{children:"letter_frequency_concurrent.go](./code/letter_frequency_concurrent.go), we can see that the"}),"frequency",(0,t.jsx)(n.code,{children:"slice of integers is passed into the"}),"countLetters` function where the slice is modified."]}),"\n",(0,t.jsxs)(n.p,{children:["The program has a race condition though. If we run and compare the results between ",(0,t.jsx)(n.code,{children:"letter_frequency_concurrent.go"})," and ",(0,t.jsx)(n.code,{children:"letter_frequency_seq.go"}),", we can see that the letter 'e' has a different frequency:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:' go run docs/software/languages/go/concurrency/code/letter_frequency_concurrent.go | grep -E "e-"\ne-161063\n\n go run docs/software/languages/go/concurrency/code/letter_frequency_seq.go | grep -E "e-"\ne-178215\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Every time we run ",(0,t.jsx)(n.code,{children:"letter_frequency_concurrent.go"}),", we will get a different result. This is because the program has a race condition. This means that multiple threads/processes share a resource but step over each other."]}),"\n",(0,t.jsx)(n.h4,{id:"race-conditions",children:"Race Conditions"}),"\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:o(94161).A+"",children:"`race_condition_demo.go"}),", we can see that we have a variable with an initial value (100) that we pass as a reference to 2 functions that either increase or decrease the value by 10. We run this increase and decrease the same amount of times in its own goroutine so we're expecting that after the functions finish, the amount would equal to the initial value. But this doesn't happen."]}),"\n",(0,t.jsxs)(n.p,{children:["The cause is that the increase/decrease operation is not an ",(0,t.jsx)(n.strong,{children:"atomic operation"}),". An atomic operation is an operation that is indivisible and cannot be interrupted. The ",(0,t.jsx)(n.code,{children:"*money -= 10"})," and ",(0,t.jsx)(n.code,{children:"*money += 10"})," operations have 3 steps:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Read the value of the integer, ",(0,t.jsx)(n.code,{children:"money"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Modify the value."}),"\n",(0,t.jsx)(n.li,{children:"Write the modified value back to memory."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["We can use the ",(0,t.jsx)(n.code,{children:"sync/atomic"})," and ",(0,t.jsx)(n.code,{children:"atomic.AddInt32/64"})," that can safely increment or decrement shared variables. Also, if we set the program to use only one processor using ",(0,t.jsx)(n.code,{children:"GOMAXPROCS=1"}),", all goroutines will run on the same processor and use the same cache so we see the expected behavior:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"GOMAXPROCS=1 go run docs/software/languages/go/concurrency/code/race_condition_demo.go\nSpendy Done\nStingy Done\nMoney in bank account:  100\n\nGOMAXPROCS=1 go run docs/software/languages/go/concurrency/code/race_condition_demo.go\nSpendy Done\nStingy Done\nMoney in bank account:  100\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Using ",(0,t.jsx)(n.code,{children:"GOMAXPROCS"})," is obviously not a good solution because this would take away the advantage of concurrency."]}),"\n",(0,t.jsx)(n.h4,{id:"solving-race-conditions",children:"Solving Race Conditions"}),"\n",(0,t.jsx)(n.p,{children:"There's no single technique to solve all race conditions. We need to consider:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Is memory sharing really needed for the problem or is there another way to communicate between goroutines? We can use channels as well."}),"\n",(0,t.jsx)(n.li,{children:"Is there a chance that a race condition can occur with the program?"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"To avoid race conditions, we need good synchronization and communcation with the rest of the goroutines."}),"\n",(0,t.jsx)(n.h4,{id:"detecting-race-conditions",children:"Detecting Race Conditions"}),"\n",(0,t.jsxs)(n.p,{children:["We can use the ",(0,t.jsx)(n.code,{children:"-race"})," command line flag to detect race conditions. The compiler adds special code to all memory accesses to track when goroutines are reading and writing memory and outputs memory locations and source code line numbers where the program read/wrote to, causing a race condition."]})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},66313:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/files/countdown-e0fca66cbeda614c05a58c7283435654.go"},94161:(e,n,o)=>{o.d(n,{A:()=>t});const t=o.p+"assets/files/race_condition_demo-e34742baf009cdffc857e48304c2ff89.go"},28453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>i});var t=o(96540);const r={},a=t.createContext(r);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);