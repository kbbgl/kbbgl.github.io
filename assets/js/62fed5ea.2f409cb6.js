"use strict";(globalThis.webpackChunkkgkb=globalThis.webpackChunkkgkb||[]).push([[50211],{37524:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>t,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var l=s(74848),r=s(28453);const i={slug:"os-linux-kernel-managing-kernel-and-loadable-kernel-modules",title:"Managing Kernel and Loadable Kernel Modules",authors:["kbbgl"],tags:["os","linux","kernel","managing_kernel_and_loadable_kernel_modules"]},a=void 0,o={id:"os/linux/kernel/managing_kernel_and_loadable_kernel_modules",title:"Managing Kernel and Loadable Kernel Modules",description:"The Linux\xae kernel is the main component of a Linux operating system (OS) and is the core interface between a computer\u2019s hardware and its processes. It communicates between the 2, managing resources as efficiently as possible.",source:"@site/docs/os/linux/kernel/managing_kernel_and_loadable_kernel_modules.md",sourceDirName:"os/linux/kernel",slug:"/os/linux/kernel/os-linux-kernel-managing-kernel-and-loadable-kernel-modules",permalink:"/docs/os/linux/kernel/os-linux-kernel-managing-kernel-and-loadable-kernel-modules",draft:!1,unlisted:!1,tags:[{inline:!0,label:"os",permalink:"/docs/tags/os"},{inline:!0,label:"linux",permalink:"/docs/tags/linux"},{inline:!0,label:"kernel",permalink:"/docs/tags/kernel"},{inline:!0,label:"managing_kernel_and_loadable_kernel_modules",permalink:"/docs/tags/managing-kernel-and-loadable-kernel-modules"}],version:"current",frontMatter:{slug:"os-linux-kernel-managing-kernel-and-loadable-kernel-modules",title:"Managing Kernel and Loadable Kernel Modules",authors:["kbbgl"],tags:["os","linux","kernel","managing_kernel_and_loadable_kernel_modules"]},sidebar:"docsSidebar",previous:{title:"`dmesg`",permalink:"/docs/os/linux/kernel/os-linux-kernel-dmesg"},next:{title:"Modules",permalink:"/docs/os/linux/kernel/os-linux-kernel-module"}},t={},c=[{value:"Kernel Module",id:"kernel-module",level:3},{value:"Checking the Kernel Version",id:"checking-the-kernel-version",level:4},{value:"Kernel Tuning with <code>sysctl</code>",id:"kernel-tuning-with-sysctl",level:4},{value:"Managing Kernel Modules",id:"managing-kernel-modules",level:4},{value:"Write kernel module",id:"write-kernel-module",level:3}];function d(e){const n={code:"code",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.p,{children:"The Linux\xae kernel is the main component of a Linux operating system (OS) and is the core interface between a computer\u2019s hardware and its processes. It communicates between the 2, managing resources as efficiently as possible."}),"\n",(0,l.jsx)(n.p,{children:"The kernel has 4 jobs:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Memory management: Keep track of how much memory is used to store what, and where"}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Process management: Determine which processes can use the central processing unit (CPU), when, and for how long"}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Device drivers: Act as mediator/interpreter between the hardware and processes"}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"System calls and security: Receive requests for service from the processes"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Where the kernel fits within the OS\nTo put the kernel in context, you can think of a Linux machine as having 3 layers:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"The hardware: The physical machine\u2014the bottom or base of the system, made up of memory (RAM) and the processor or central processing unit (CPU), as well as input/output (I/O) devices such as storage, networking, and graphics. The CPU performs computations and reads from, and writes to, memory."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"The Linux kernel: The core of the OS. It\u2019s software residing in memory that tells the CPU what to do."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"User processes: These are the running programs that the kernel manages. User processes are what collectively make up user space. User processes are also known as just processes. The kernel also allows these processes and servers to communicate with each other (known as inter-process communication, or IPC)."}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Memory get's divided into two distinct areas:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"The user space, which is a set of locations where normal user processes run (i.e everything other than the kernel). The role of the kernel is to manage applications running in this space from messing with each other, and the machine."}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"The kernel space, which is the location where the code of the kernel is stored, and executes under."}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Processes running under the user space have access only to a limited part of memory, whereas the kernel has access to all of the memory."}),"\n",(0,l.jsxs)(n.p,{children:["Processes running in user space also don't have access to the kernel space (except for ",(0,l.jsx)(n.code,{children:"root"}),"). User space processes can only access a small part of the kernel via an interface exposed by the kernel - the system calls. If a process performs a system call, a software interrupt is sent to the kernel, which then dispatches the appropriate interrupt handler and continues its work after the handler has finished."]}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.img,{src:"https://www.differencebetween.com/wp-content/uploads/2017/12/Difference-Between-User-Mode-and-Kernel-Mode-fig-2.png",alt:""})}),"\n",(0,l.jsx)(n.p,{children:"Kernel space code has the property to run in \"kernel mode\", which (in your typical desktop -x86- computer) is what you call code that executes under ring 0. Typically in x86 architecture, there are 4 rings of protection. Ring 0 (kernel mode), Ring 1 (may be used by virtual machine hypervisors or drivers), Ring 2 (may be used by drivers, I am not so sure about that though). Ring 3 is what typical applications run under. It is the least privileged ring, and applications running on it have access to a subset of the processor's instructions. Ring 0 (kernel space) is the most privileged ring, and has access to all of the machine's instructions."}),"\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.img,{src:"https://upload.wikimedia.org/wikipedia/commons/2/2f/Priv_rings.svg",alt:"rings"})}),"\n",(0,l.jsx)(n.h3,{id:"kernel-module",children:"Kernel Module"}),"\n",(0,l.jsxs)(n.p,{children:["Loadable kernel modules (",(0,l.jsx)(n.strong,{children:"LKMs"}),") are modules that can be added to the Linux kernel. These modules are usually used for:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Device drivers - Used to communicate and manage external hardware with the OS."}),"\n",(0,l.jsx)(n.li,{children:"Filesystem drivers"}),"\n",(0,l.jsx)(n.li,{children:"System calls - User space programs use system calls to get services from the kernel. For example, there are system calls to read a file, to create a new process, and to shut down the system. Most system calls are integral to the system and very standard, so are always built into the base kernel (no LKM option). But you can invent a system call of your own and install it as an LKM. Or you can decide you don't like the way Linux does something and override an existing system call with an LKM of your own."}),"\n",(0,l.jsx)(n.li,{children:"Network drivers"}),"\n",(0,l.jsx)(n.li,{children:"TTY line disciplines"}),"\n",(0,l.jsx)(n.li,{children:"Executable interpreters"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Rootkits are usually written as LKMs which allow hackers to be able to control what the target system is reporting in terms of processes, ports, services, hard drive space."}),"\n",(0,l.jsx)(n.h4,{id:"checking-the-kernel-version",children:"Checking the Kernel Version"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"uname -a\n"})}),"\n",(0,l.jsx)(n.p,{children:"Or:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"cat /proc/version\n"})}),"\n",(0,l.jsxs)(n.h4,{id:"kernel-tuning-with-sysctl",children:["Kernel Tuning with ",(0,l.jsx)(n.code,{children:"sysctl"})]}),"\n",(0,l.jsxs)(n.p,{children:["We can modify kernel behavior using ",(0,l.jsx)(n.code,{children:"sysctl"}),". Any changes made will be effective until reboot. To make the changes permanent, we need to edit the ",(0,l.jsx)(n.code,{children:"/etc/sysctl.conf"})," file."]}),"\n",(0,l.jsx)(n.p,{children:"To see the available options for tuning:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"sudo systcl -a\n"})}),"\n",(0,l.jsx)(n.p,{children:"To enable packet forwarding (for MITM):"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"sudo sysctl -w net.ipv4.ip_forward=1\n"})}),"\n",(0,l.jsxs)(n.p,{children:["To make this change permanent by editing ",(0,l.jsx)(n.code,{children:"/etc/sysctl.conf"})," and uncommenting the same line."]}),"\n",(0,l.jsxs)(n.p,{children:["To make system unpingable, add to ",(0,l.jsx)(n.code,{children:"/etc/sysctl.conf"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"net.ipv4.icmp_echo_ignore_all=1\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Then run to load in ",(0,l.jsx)(n.code,{children:"sysctl"})," settings from ",(0,l.jsx)(n.code,{children:"/etc/sysctl.conf"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"sysctl -p\n"})}),"\n",(0,l.jsx)(n.h4,{id:"managing-kernel-modules",children:"Managing Kernel Modules"}),"\n",(0,l.jsx)(n.p,{children:"Linux has 2 ways to manage modules:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"insmod"})," suite (insert module) or ",(0,l.jsx)(n.code,{children:"rmmod"})," (remove module). Need to be used with caution because they do not take into account module dependencies."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"modprobe"})," command - preferable and modern way to interact with modules."]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"To list installed modules, their size and which modules are using it:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"lsmod\n"})}),"\n",(0,l.jsx)(n.p,{children:"To gather more info on a module:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"modinfo $MODULE_NAME\n"})}),"\n",(0,l.jsxs)(n.p,{children:["It will also print the ",(0,l.jsx)(n.code,{children:"depends"})," property which lists the module dependencies."]}),"\n",(0,l.jsx)(n.p,{children:"To insert a module:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"modprobe -a $NAME_OF_MODULE\n"})}),"\n",(0,l.jsx)(n.p,{children:"To print the kernel message buffer:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"dmesg\n"})}),"\n",(0,l.jsx)(n.p,{children:"To remove a module:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"modprobe -r $NAME_OF_MODULE\n"})}),"\n",(0,l.jsx)(n.h3,{id:"write-kernel-module",children:"Write kernel module"}),"\n",(0,l.jsxs)(n.p,{children:["A kernel module is a piece of code, usually written in ",(0,l.jsx)(n.code,{children:"c"})," that can interact with Ring 0."]}),"\n",(0,l.jsx)(n.p,{children:"Steps are:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["Create ",(0,l.jsx)(n.code,{children:"lkm_example.c"})," with sample:"]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-c",children:'#include <linux/kernel.h>\n#include <linux/module.h>\n\n\n/*\n * Init function of our module\n */\nstatic int __init hellokernelmod_init(void)\n{\n printk(KERN_INFO "Hello Kernel!\\n");\n return 0;\n}\n\n/*\n * Exit function of our module.\n */\nstatic void __exit hellokernelmod_exit(void)\n{\n printk(KERN_INFO "Hasta la vista, Kernel!\\n");\n}\n\nMODULE_AUTHOR("Your name here");\nMODULE_DESCRIPTION("Simple Kernel Module to display messages on init and exit.");\nMODULE_LICENSE("MIT");\n\n\nmodule_init(hellokernelmod_init);\nmodule_exit(hellokernelmod_exit);\n'})}),"\n",(0,l.jsxs)(n.ol,{start:"2",children:["\n",(0,l.jsxs)(n.li,{children:["Create ",(0,l.jsx)(n.code,{children:"Makefile"})]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"obj-m += lkm_example.o\n\nall:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\nclean:\n\tmake -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\n"})}),"\n",(0,l.jsxs)(n.ol,{start:"3",children:["\n",(0,l.jsx)(n.li,{children:"Compile:"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"make\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This will create a ",(0,l.jsx)(n.code,{children:"lkm_example.ko"})," file.\nWe can check the module description by:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"modinfo lkm_example.ko\n"})}),"\n",(0,l.jsxs)(n.ol,{start:"4",children:["\n",(0,l.jsx)(n.li,{children:"Insert module into kernel:"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"sudo insmod lkm_example.ko\n"})}),"\n",(0,l.jsxs)(n.ol,{start:"5",children:["\n",(0,l.jsx)(n.li,{children:"Verify the insertion:"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"lsmod | grep lkm_example\n"})}),"\n",(0,l.jsxs)(n.ol,{start:"6",children:["\n",(0,l.jsx)(n.li,{children:"See messages:"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"dmesg\n\n#[11144.986911] lkm_example: loading out-of-tree module taints kernel.\n#[11144.986914] lkm_example: module license 'MIT' taints kernel.\n#[11144.986915] Disabling lock debugging due to kernel taint\n#[11144.987001] lkm_example: module verification failed: signature and/or required key missing - tainting kernel\n#[11144.989369] module initialized\n"})}),"\n",(0,l.jsxs)(n.ol,{start:"7",children:["\n",(0,l.jsx)(n.li,{children:"Remove module:"}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"sudo rmmod lkm_example\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"dmesg\n#[11404.347066] module exiting\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var l=s(96540);const r={},i=l.createContext(r);function a(e){const n=l.useContext(i);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),l.createElement(i.Provider,{value:n},e.children)}}}]);