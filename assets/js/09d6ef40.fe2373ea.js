"use strict";(globalThis.webpackChunkkgkb=globalThis.webpackChunkkgkb||[]).push([[47937],{12713:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var s=t(74848),o=t(28453);const i={slug:"how-to-set-up-split-tunneling",title:"How To Set Up Split Tunneling with VPN",description:"This blog post describes how to set up split tunneling with a VPN on MacOS.",authors:["kgal-akl"],tags:["vpn","network","route","routing","macos","unix"],date:new Date("2025-10-19T00:00:00.000Z")},a=void 0,r={permalink:"/blog/how-to-set-up-split-tunneling",source:"@site/blog/how-to-set-up-split-tunneling.md",title:"How To Set Up Split Tunneling with VPN",description:"This blog post describes how to set up split tunneling with a VPN on MacOS.",date:"2025-10-19T00:00:00.000Z",tags:[{inline:!1,label:"Vpn",permalink:"/blog/tags/vpn"},{inline:!1,label:"Network",permalink:"/blog/tags/network"},{inline:!1,label:"Route",permalink:"/blog/tags/route"},{inline:!1,label:"Routing",permalink:"/blog/tags/routing"},{inline:!1,label:"Macos",permalink:"/blog/tags/macos"},{inline:!1,label:"Unix",permalink:"/blog/tags/unix"}],readingTime:5.09,hasTruncateMarker:!0,authors:[{name:"Kobbi Gal (Akeyless)",title:"Escalations Engineer at Akeyless",url:"https://github.com/kgal-akl",imageURL:"https://avatars.githubusercontent.com/u/195813801",key:"kgal-akl",page:null}],frontMatter:{slug:"how-to-set-up-split-tunneling",title:"How To Set Up Split Tunneling with VPN",description:"This blog post describes how to set up split tunneling with a VPN on MacOS.",authors:["kgal-akl"],tags:["vpn","network","route","routing","macos","unix"],date:"2025-10-19T00:00:00.000Z"},unlisted:!1,prevItem:{title:"How to Deploy Kubernetes Services using Gateway API/AWS Load Balancer Controller",permalink:"/blog/how-to-deploy-k8s-svcs-using-aws-lbc-gw-api"},nextItem:{title:"3-Way Data Migration between Support\xa0Systems",permalink:"/blog/3-way-data-migration-between-support-systems"}},l={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"Collection",id:"collection",level:2},{value:"Service Hostname to CIDR IP Address",id:"service-hostname-to-cidr-ip-address",level:3},{value:"Network Interfaces",id:"network-interfaces",level:3},{value:"Change Routing Tables",id:"change-routing-tables",level:2},{value:"(Optional) Split Tunnel on VPN Connection on MacOS",id:"optional-split-tunnel-on-vpn-connection-on-macos",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"A lot of our work nowadays requires using and connecting to a Virtual Private Networks (VPNs) in order to access certain resources (e.g. databases, websites, REST APIs) that were deemed important to protect from the public internet. When we connect to the VPN, we're able to access these resources."}),"\n",(0,s.jsx)(n.p,{children:"The nature of our modern digital work requires simultaneous access to a plethora of services. Some of these services require an active VPN connection and some can be accessed without."}),"\n",(0,s.jsx)(n.p,{children:"At times, the VPN we need to connect to is geolocated far from us. In addition, the VPN can be one that serves the entire company and is not very performant. These factors result in an experience of collective latency accessing resources, restricted and unrestricted ones alike."}),"\n",(0,s.jsx)(n.p,{children:"If you find/found yourself in this type of situation before, this post will explain how you can circumvent that and suffer latency only when accessing the restricted resources instead of all resources by modifying the operating system routing tables in what's called 'Split Tunneling'."}),"\n",(0,s.jsx)(n.p,{children:"To do this you will need to have root/administrator access to the UNIX operating system."}),"\n",(0,s.jsx)(n.p,{children:"We begin by collecting the relevant information and later performing the modifications."}),"\n",(0,s.jsx)(n.h2,{id:"collection",children:"Collection"}),"\n",(0,s.jsxs)(n.p,{children:["The first thing we will need to do is to collect the IP addresses of the restricted services that we want to only access using the VPN. In the example below I will use ",(0,s.jsx)(n.code,{children:"global.svc.dev"}),", ",(0,s.jsx)(n.code,{children:"us.svc.dev"}),", ",(0,s.jsx)(n.code,{children:"eu.svc.dev"})," as the hostnames for the services that require access."]}),"\n",(0,s.jsx)(n.h3,{id:"service-hostname-to-cidr-ip-address",children:"Service Hostname to CIDR IP Address"}),"\n",(0,s.jsx)(n.p,{children:"If we don't have those readily-available, we'll need to connect to the VPN as we usually do and lookup the service:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'\u276f RESTRICTED_SERVICES_HOSTNAMES=("global.svc.dev" "us.svc.dev" "eu.svc.dev")\n\u276f for HOSTNAME in "${RESTRICTED_SERVICES_HOSTNAMES[@]}"; do\n    CIDR_ADDRESS="$(nslookup HOSTNAME | grep Address | tail -1 | cut -d" " -f2)/32";\n    echo "$HOSTNAME => $CIDR_ADDRESS\ndone\n\nglobal.svc.dev => 123.123.123.123/32\nus.svc.dev => 213.213.213.213/32\neu.svc.dev => 122.133.111.222/32\n'})}),"\n",(0,s.jsx)(n.h3,{id:"network-interfaces",children:"Network Interfaces"}),"\n",(0,s.jsx)(n.p,{children:"Now that we have the IP addresses of the restricted services, we need to find the names of the network interfaces which we will manipulate. The relevant network interfaces are the VPN and the local one (the one that is used when the VPN is not needed)."}),"\n",(0,s.jsxs)(n.p,{children:["To find both interfaces we use ",(0,s.jsx)(n.code,{children:"ifconfig"}),".\nFor the VPN interface it'll usually be named something like ",(0,s.jsx)(n.code,{children:"utun[1-4]"})," or ",(0,s.jsx)(n.code,{children:"ppp[0-4]"}),". As for the local interface, it'll either be ",(0,s.jsx)(n.code,{children:"en0"})," or ",(0,s.jsx)(n.code,{children:"en1"}),". Here's a shortened example output:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"\u276f ifconfig\n\nen0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n        inet 10.100.1.165 netmask 0xffffff00 broadcast 10.100.1.255\n        status: active\n...\nutun4: flags=8051<UP,POINTOPOINT,RUNNING,MULTICAST> mtu 1340\n        inet 192.168.111.222 --\x3e 192.168.111.222 netmask 0xffffffff\n"})}),"\n",(0,s.jsxs)(n.p,{children:["We can see from the output above that the local interface is named ",(0,s.jsx)(n.code,{children:"en01"})," and is currently assigned IP address 10.100.1.165 and the VPN interface is named ",(0,s.jsx)(n.code,{children:"utun4"})," and has an internal IP address of 192.168.111.222. The VPN client application will usually print out this IP address so you can always compare it to the one you see from the ",(0,s.jsx)(n.code,{children:"ifconfig"})," output."]}),"\n",(0,s.jsx)(n.p,{children:"Not necessary but we can also see the default gateway IP (usually the ISP-provided router) used by the local network interface:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"\u276f netstat -nr | grep default | grep en0\ndefault            192.168.1.1        UGScIg                en0\n"})}),"\n",(0,s.jsx)(n.h2,{id:"change-routing-tables",children:"Change Routing Tables"}),"\n",(0,s.jsx)(n.p,{children:"Now that we have all the information we need, we can modify the routing tables."}),"\n",(0,s.jsx)(n.p,{children:"The routing instructions needed are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reset routing of requests to the VPN interface on the default network:"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"\u276f sudo route delete -net default -interface utun4\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Set route requests to the local interface on the default network."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"\u276f sudo route add -net 0.0.0.0 -interface en0\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Route each request sent to a restricted IP address to the VPN interface."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'\u276f for ip in "${RESTRICTED_SITES[@]}";do\n        sudo route add -net $ip -interface $VPN_INTERFACE;\ndone\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Putting it all together in a script ",(0,s.jsx)(n.code,{children:"/path/to/split_tunnel.sh"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'#!/usr/bin/env bash\n\n\u276f VPN_INTERFACE="utun4"\n\u276f LOCAL_INTERFACE="en0"\n\u276f RESTRICTED_SERVICES_HOSTNAMES=("global.svc.dev" "us.svc.dev" "eu.svc.dev")\n\u276f RESTRICTED_SERVICES_CIDR_ADDRESSES=()\n\u276f for HOSTNAME in "${RESTRICTED_SERVICES_HOSTNAMES[@]}"; do\n    CIDR_ADDRESS="$(nslookup HOSTNAME | grep Address | tail -1 | cut -d\' \' -f2)/32";\n    RESTRICTED_SERVICES_CIDR_ADDRESSES+=(CIDR_ADDRESS)\ndone\n\n\u276f sudo route delete -net default -interface $VPN_INTERFACE\n# output delete net default: gateway $VPN_INTERFACE\n\n\u276f sudo route add -net 0.0.0.0 -interface $LOCAL_INTERFACE\n# output add net 0.0.0.0: gateway $LOCAL_INTERFACE\n\n\u276f for ip in "${RESTRICTED_SERVICES_CIDR_ADDRESSES[@]}";do\n        sudo route add -net $ip -interface $VPN_INTERFACE;\ndone\n\n# output\n# add net 123.123.123.123/32: gateway $VPN_INTERFACE\n# add net 213.213.213.213/32: gateway $VPN_INTERFACE\n# add net 122.133.111.222/32: gateway $VPN_INTERFACE\n'})}),"\n",(0,s.jsx)(n.p,{children:"After running this script, we'll be able to access the non-restricted services without going through the VPN."}),"\n",(0,s.jsx)(n.p,{children:"Keep in mind that these changes will not persistent and will likely be reset every time you disconnect/connect to the VPN. The following section explains how to set up automatically running the script when the VPN interface is detected."}),"\n",(0,s.jsx)(n.h2,{id:"optional-split-tunnel-on-vpn-connection-on-macos",children:"(Optional) Split Tunnel on VPN Connection on MacOS"}),"\n",(0,s.jsx)(n.p,{children:"The goal is for us to run the script above every time we connect to the VPN."}),"\n",(0,s.jsx)(n.p,{children:"We first need to confirm whether the VPN interface name assigned is constant. To do that, we can list the names of the interfaces before and after we connect and disconnect from the VPN:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"\u276f watch ifconfig -l\n\n# not connected to VPN\nlo0 en1 bridge0 ap1 en0 utun0 utun1 utun2 utun3\n\n# connected to VPN\nlo0 en1 bridge0 ap1 en0 utun0 utun1 utun2 utun3 utun4\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As we can see from the output above, ",(0,s.jsx)(n.code,{children:"utun4"})," was added when we connected to the VPN so we can be pretty confident that the name of the VPN interface is constant."]}),"\n",(0,s.jsxs)(n.p,{children:["Now that we confirmed the VPN interface name is constant, we can set up a ",(0,s.jsx)(n.code,{children:"launchd"})," agent to monitor for changes in the specific VPN interface device (e.g. ",(0,s.jsx)(n.code,{children:"/dev/utun4"}),")."]}),"\n",(0,s.jsxs)(n.p,{children:["To do this, we need to create a ",(0,s.jsx)(n.code,{children:"launchd"})," property list (",(0,s.jsx)(n.code,{children:"plist"}),") file in ",(0,s.jsx)(n.code,{children:"~/Library/LaunchAgents/com.kbbgl.split_tunnel.plist"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",metastring:'title="~/Library/LaunchAgents/com.kbbgl.split_tunnel.plist"',children:'<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n    <key>Label</key>\n    <string>com.kbbgl.split_tunnel</string>\n    <key>ProgramArguments</key>\n    <array>\n        \x3c!-- TODO change path to script --\x3e\n        <string>/path/to/split_tunnel.sh</string>  \n    </array>\n    <key>WatchPaths</key>\n    <array>\n        \x3c!-- TODO change name of VPN interface --\x3e\n        <string>/dev/utun4</string>  </array>\n    <key>RunAtLoad</key>\n    <true/>\n    <key>StandardOutPath</key>\n    <string>/tmp/split_tunnel.log</string>\n    <key>StandardErrorPath</key>\n    <string>/tmp/split_tunnel.log</string>\n</dict>\n</plist>\n'})}),"\n",(0,s.jsx)(n.p,{children:"And load the new agent:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"\u276f launchctl load ~/Library/LaunchAgents/com.kbbgl.split_tunnel.plist\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(96540);const o={},i=s.createContext(o);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);